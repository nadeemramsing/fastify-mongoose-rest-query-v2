{
  "version": 3,
  "sources": ["../../src/handler/sub.handler.ts", "../../src/mrq.enum.ts", "../../src/services/sub.service.ts", "../../src/mrq.config.ts", "../../src/utils/mongoose.utils.ts", "../../src/mrq.errors.ts", "../../src/utils/db.utils.ts", "../../src/utils/query.sub.utils.ts", "../../src/utils/query.utils.ts"],
  "sourcesContent": ["import { RouteHandlerMethod } from 'fastify'\nimport { httpErrors } from '@fastify/sensible'\nimport { HandlerAccessEnum } from '../mrq.enum'\nimport * as subService from '../services/sub.service'\nimport { getQueryForSubarray } from '../utils/query.sub.utils'\nimport { ROLE_DOES_NOT_HAVE_ACCESS_HANDLER_LEVEL } from '../mrq.errors'\nimport { ISchemaOption } from '../mrq.interfaces'\n\nexport const getSubHandler = (\n  modelName: string,\n  {\n    subPathName,\n    handlerAccesses,\n    getSubarray,\n    subIdName,\n  }: Omit<ISchemaOption, 'endpointName'>\n) => {\n  const getByQuery: RouteHandlerMethod = async (req, rep) => {\n    if (!handlerAccesses.includes(HandlerAccessEnum.GET_BY_ID_SUB))\n      throw httpErrors.unauthorized(ROLE_DOES_NOT_HAVE_ACCESS_HANDLER_LEVEL)\n\n    const { subarray } = await getSubarray(req, modelName, subPathName, true)\n\n    const query = getQueryForSubarray(req.query)\n\n    return subService.getByQuery({ query, subarray })\n  }\n\n  // ---\n\n  const count: RouteHandlerMethod = async (req, rep) => {\n    if (!handlerAccesses.includes(HandlerAccessEnum.COUNT_SUB))\n      throw httpErrors.unauthorized(ROLE_DOES_NOT_HAVE_ACCESS_HANDLER_LEVEL)\n\n    const { subarray } = await getSubarray(req, modelName, subPathName, true)\n\n    const query = getQueryForSubarray(req.query, { ignoreSelect: true })\n\n    return subService.count({ query, subarray })\n  }\n\n  // ---\n\n  const distinct: RouteHandlerMethod = async (req, rep) => {\n    if (!handlerAccesses.includes(HandlerAccessEnum.DISTINCT_SUB))\n      throw httpErrors.unauthorized(ROLE_DOES_NOT_HAVE_ACCESS_HANDLER_LEVEL)\n\n    const { subarray } = await getSubarray(req, modelName, subPathName, true)\n\n    const query = getQueryForSubarray(req.query, { ignoreSelect: true })\n\n    const { path } = req.params as { path: string }\n\n    return subService.distinct({ query, path, subarray })\n  }\n\n  // ---\n\n  const create: RouteHandlerMethod = async (req, rep) => {\n    if (!handlerAccesses.includes(HandlerAccessEnum.CREATE_SUB))\n      throw httpErrors.unauthorized(ROLE_DOES_NOT_HAVE_ACCESS_HANDLER_LEVEL)\n\n    const { Model, doc, subarray } = await getSubarray(\n      req,\n      modelName,\n      subPathName\n    )\n\n    return subService.create({\n      body: req.body,\n      doc,\n      Model,\n      req,\n      subarray,\n    })\n  }\n\n  // ---\n\n  const updateMany: RouteHandlerMethod = async (req, rep) => {\n    if (!handlerAccesses.includes(HandlerAccessEnum.UPDATE_MANY_SUB))\n      throw httpErrors.unauthorized(ROLE_DOES_NOT_HAVE_ACCESS_HANDLER_LEVEL)\n\n    const { Model, doc, subarray } = await getSubarray(\n      req,\n      modelName,\n      subPathName\n    )\n\n    return subService.updateMany({\n      body: req.body,\n      doc,\n      Model,\n      req,\n      subarray,\n    })\n  }\n\n  // ---\n\n  const deleteByQuery: RouteHandlerMethod = async (req, rep) => {\n    if (!handlerAccesses.includes(HandlerAccessEnum.DELETE_BY_QUERY_SUB))\n      throw httpErrors.unauthorized(ROLE_DOES_NOT_HAVE_ACCESS_HANDLER_LEVEL)\n\n    const { Model, doc, subarray } = await getSubarray(\n      req,\n      modelName,\n      subPathName\n    )\n\n    const query = getQueryForSubarray(req.query, { ignoreSelect: true })\n\n    return subService.deleteByQuery({ doc, Model, req, subarray, query })\n  }\n\n  // ---\n\n  const getById: RouteHandlerMethod = async (req, rep) => {\n    if (!handlerAccesses.includes(HandlerAccessEnum.GET_BY_ID_SUB))\n      throw httpErrors.unauthorized(ROLE_DOES_NOT_HAVE_ACCESS_HANDLER_LEVEL)\n\n    const { subarray } = await getSubarray(req, modelName, subPathName)\n\n    const params = req.params as { [key: string]: string }\n\n    const query = getQueryForSubarray(req.query)\n\n    return subService.getById({ query, subarray, subId: params[subIdName] })\n  }\n\n  // ---\n\n  const updateById: RouteHandlerMethod = async (req, rep) => {\n    if (!handlerAccesses.includes(HandlerAccessEnum.UPDATE_BY_ID_SUB))\n      throw httpErrors.unauthorized(ROLE_DOES_NOT_HAVE_ACCESS_HANDLER_LEVEL)\n\n    const { Model, doc, subarray } = await getSubarray(\n      req,\n      modelName,\n      subPathName\n    )\n\n    const params = req.params as { [key: string]: string }\n\n    return subService.updateById({\n      body: req.body,\n      subId: params[subIdName],\n      doc,\n      Model,\n      req,\n      subarray,\n    })\n  }\n\n  // ---\n\n  const deleteById: RouteHandlerMethod = async (req, rep) => {\n    if (!handlerAccesses.includes(HandlerAccessEnum.DELETE_BY_ID_SUB))\n      throw httpErrors.unauthorized(ROLE_DOES_NOT_HAVE_ACCESS_HANDLER_LEVEL)\n\n    const { Model, doc, subarray } = await getSubarray(\n      req,\n      modelName,\n      subPathName\n    )\n\n    const params = req.params as { [key: string]: string }\n\n    return subService.deleteById({\n      doc,\n      Model,\n      req,\n      subarray,\n      subId: params[subIdName],\n    })\n  }\n\n  return {\n    getByQuery,\n    count,\n    distinct,\n    create,\n    updateMany,\n    deleteByQuery,\n\n    getById,\n    updateById,\n    deleteById,\n  }\n}\n", "export enum HandlerAccessEnum {\n  // MAIN\n  CREATE_INDEX = 'CREATE_INDEX',\n  GET_BY_QUERY = 'GET_BY_QUERY',\n  COUNT = 'COUNT',\n  DISTINCT = 'DISTINCT',\n  CREATE = 'CREATE',\n  DELETE_BY_QUERY = 'DELETE_BY_QUERY',\n  UPDATE_MANY = 'UPDATE_MANY',\n\n  // MAIN WITH ID\n  GET_BY_ID = 'GET_BY_ID',\n  UPDATE_BY_ID = 'UPDATE_BY_ID',\n  DELETE_BY_ID = 'DELETE_BY_ID',\n\n  // SUB\n  GET_BY_QUERY_SUB = 'GET_BY_QUERY_SUB',\n  COUNT_SUB = 'COUNT_SUB',\n  DISTINCT_SUB = 'DISTINCT_SUB',\n  CREATE_SUB = 'CREATE_SUB',\n  UPDATE_MANY_SUB = 'UPDATE_MANY_SUB',\n  DELETE_BY_QUERY_SUB = 'DELETE_BY_QUERY_SUB',\n\n  // SUB WITH ID\n  GET_BY_ID_SUB = 'GET_BY_ID_SUB',\n  UPDATE_BY_ID_SUB = 'UPDATE_BY_ID_SUB',\n  DELETE_BY_ID_SUB = 'DELETE_BY_ID_SUB',\n}\n\nexport const ALL_GET = [\n  HandlerAccessEnum.GET_BY_QUERY,\n  HandlerAccessEnum.GET_BY_QUERY_SUB,\n  HandlerAccessEnum.GET_BY_ID,\n  HandlerAccessEnum.GET_BY_ID_SUB,\n  HandlerAccessEnum.COUNT,\n  HandlerAccessEnum.COUNT_SUB,\n  HandlerAccessEnum.DISTINCT,\n  HandlerAccessEnum.DISTINCT_SUB,\n]\n\nexport const ALL_POST = [HandlerAccessEnum.CREATE, HandlerAccessEnum.CREATE_SUB]\n\nexport const ALL_PUT = [\n  HandlerAccessEnum.UPDATE_MANY,\n  HandlerAccessEnum.UPDATE_MANY_SUB,\n  HandlerAccessEnum.UPDATE_BY_ID,\n  HandlerAccessEnum.UPDATE_BY_ID_SUB,\n]\n\nexport const ALL_DELETE = [\n  HandlerAccessEnum.DELETE_BY_QUERY,\n  HandlerAccessEnum.DELETE_BY_QUERY_SUB,\n  HandlerAccessEnum.DELETE_BY_ID,\n  HandlerAccessEnum.DELETE_BY_ID_SUB,\n]\n\nexport const ALL_HANDLERS = [...ALL_GET, ...ALL_POST, ...ALL_PUT, ...ALL_DELETE]\n", "import { ObjectId } from 'bson'\nimport { Model, Types } from 'mongoose'\nimport { FastifyRequest } from 'fastify'\nimport fp from 'lodash/fp'\nimport sift from 'sift'\nimport { MrqDocument, MrqQuery } from '../mrq.interfaces'\nimport { toJSONOptions } from '../mrq.config'\nimport { useSession } from '../utils/mongoose.utils'\nimport { httpErrors } from '@fastify/sensible'\nimport {\n  IMPLICIT_DELETE_ALL_NOT_ALLOWED,\n  NO_SUBITEM_FOUND,\n  SUBITEM_NOT_FOUND,\n} from '../mrq.errors'\n\ninterface IBaseOptions {\n  body: any\n  doc: MrqDocument\n  query: Omit<MrqQuery, 'populate'>\n  Model: Model<any>\n  path: string\n  req: FastifyRequest\n  subarray: any[] | Types.DocumentArray<Types.Subdocument>\n  subId: string\n}\n\nexport async function getByQuery({\n  query,\n  subarray,\n}: Pick<IBaseOptions, 'query' | 'subarray'>) {\n  return fp.pipe(\n    fp.filter(sift(query.filter)),\n    query.sort.sortFieldsArr.length\n      ? fp.orderBy(query.sort.sortFieldsArr, query.sort.sortOrderArr)\n      : (x) => x,\n    fp.drop(query.skip),\n    fp.take(query.limit),\n    fp.map(query.select.length > 1 ? fp.pick(query.select) : (x) => x)\n  )(subarray)\n}\n\n// ---\n\nexport async function count({\n  query,\n  subarray,\n}: Pick<IBaseOptions, 'query' | 'subarray'>) {\n  return fp.pipe(fp.filter(sift(query.filter)), fp.size)(subarray)\n}\n\n// ---\n\nexport async function distinct({\n  query,\n  path,\n  subarray,\n}: Pick<IBaseOptions, 'query' | 'path' | 'subarray'>) {\n  return fp.pipe(\n    fp.filter(sift(query.filter)),\n    fp.pluck(path),\n    fp.uniq,\n    fp.reject(fp.isNil)\n  )(subarray)\n}\n\n// ---\n\nexport async function create({\n  body,\n  doc,\n  Model,\n  req,\n  subarray,\n}: Pick<IBaseOptions, 'body' | 'doc' | 'Model' | 'req' | 'subarray'>) {\n  const _prev = doc.toJSON(toJSONOptions)\n\n  const idsMap = body\n    .map((item: any) => ((item._id = item._id ?? new ObjectId()), item))\n    .reduce((acc: {}, v: any) => ({ ...acc, [v._id]: true }), {})\n\n  for (const item of body) subarray.push(item)\n\n  await useSession(\n    Model,\n    req,\n    // @ts-ignore: custom arg req\n    (session?: ClientSession) => doc.save({ req, session, _prev })\n  )\n\n  const subarraySaved = subarray.map((subitem) => subitem.toJSON(toJSONOptions))\n\n  const query = req.query as { returnAll: string }\n  const shouldReturnAll = query.returnAll === 'true'\n\n  if (shouldReturnAll) return subarraySaved\n\n  return subarraySaved.filter((subitem) => idsMap[subitem._id])\n}\n\n// ---\n\nexport async function updateMany({\n  body,\n  doc,\n  Model,\n  req,\n  subarray,\n}: Pick<IBaseOptions, 'body' | 'doc' | 'Model' | 'req' | 'subarray'> & {\n  subarray: Types.DocumentArray<Types.Subdocument>\n}) {\n  const _prev = doc.toJSON(toJSONOptions)\n\n  const bodyIdsMap = body.reduce(\n    (acc: {}, v: any) => ({ ...acc, [v._id]: true }),\n    {}\n  )\n\n  const [subitemsToUpdate, subitemsToNotUpdate] = fp.partition(\n    (subitem) => bodyIdsMap[subitem._id],\n    subarray\n  )\n\n  for (const item of body) {\n    const subitem = subarray.id(item._id)\n\n    if (!subitem) continue\n\n    subitem.set(item)\n  }\n\n  if (req.routeOptions.url?.endsWith?.('/overwrite'))\n    for (const subitem of subitemsToNotUpdate) subitem.deleteOne()\n\n  await useSession(\n    Model,\n    req,\n    // @ts-ignore: custom arg req\n    (session?: ClientSession) => doc.save({ req, session, _prev })\n  )\n\n  const query = req.query as { returnAll: string }\n  const shouldReturnAll = query.returnAll === 'true'\n\n  return shouldReturnAll\n    ? subarray.map((subitem) => subitem.toJSON(toJSONOptions))\n    : subitemsToUpdate.map((subitem) => subitem.toJSON(toJSONOptions))\n}\n\n// ---\n\nexport async function deleteByQuery({\n  doc,\n  query,\n  Model,\n  req,\n  subarray,\n}: Pick<IBaseOptions, 'doc' | 'query' | 'Model' | 'req' | 'subarray'> & {\n  subarray: Types.DocumentArray<Types.Subdocument>\n}) {\n  const isDeleteAll = !Object.keys(query.filter).length\n\n  if (isDeleteAll)\n    throw httpErrors.methodNotAllowed(IMPLICIT_DELETE_ALL_NOT_ALLOWED)\n\n  const subarrayToDelete = fp.filter(\n    sift(query.filter),\n    subarray\n  ) as Types.DocumentArray<Types.Subdocument>\n\n  if (subarrayToDelete.length === 0) throw httpErrors.notFound(NO_SUBITEM_FOUND)\n\n  const _prev = doc.toJSON(toJSONOptions)\n\n  for (const subitem of subarrayToDelete) subitem.deleteOne()\n\n  await useSession(\n    Model,\n    req,\n    // @ts-ignore: custom arg req\n    (session?: ClientSession) => doc.save({ req, session, _prev })\n  )\n\n  return subarray.map((subitem) => subitem.toJSON(toJSONOptions))\n}\n\n// ---\n\nexport async function getById({\n  query,\n  subarray,\n  subId,\n}: Pick<IBaseOptions, 'query' | 'subarray' | 'subId'>) {\n  const subitem = fp.pipe(\n    fp.find((subitem: { _id: ObjectId }) => subitem._id.equals(subId)),\n    query.select.length > 1 ? fp.pick(query.select) : (x) => x\n  )(subarray)\n\n  if (!subitem || !Object.keys(subitem).length)\n    throw httpErrors.notFound(SUBITEM_NOT_FOUND)\n\n  return subitem\n}\n\n// ---\n\nexport async function updateById({\n  body,\n  doc,\n  Model,\n  req,\n  subarray,\n  subId,\n}: Pick<\n  IBaseOptions,\n  'body' | 'doc' | 'Model' | 'req' | 'subarray' | 'subId'\n> & {\n  subarray: Types.DocumentArray<Types.Subdocument>\n}) {\n  const _prev = doc.toJSON(toJSONOptions)\n\n  const subitem = subarray.id(subId)\n\n  if (!subitem) throw httpErrors.notFound(SUBITEM_NOT_FOUND)\n\n  if (req.routeOptions.url?.endsWith?.('/overwrite')) subitem.overwrite(body)\n  else subitem.set(body)\n\n  await useSession(\n    Model,\n    req,\n    // @ts-ignore: custom arg req\n    (session?: ClientSession) => doc.save({ req, session, _prev })\n  )\n\n  const query = req.query as { returnAll: string }\n  const shouldReturnAll = query.returnAll === 'true'\n\n  return shouldReturnAll\n    ? subarray.map((subitem) => subitem.toJSON(toJSONOptions))\n    : subitem.toJSON(toJSONOptions)\n}\n\n// ---\n\nexport async function deleteById({\n  doc,\n  Model,\n  req,\n  subarray,\n  subId,\n}: Pick<IBaseOptions, 'doc' | 'Model' | 'req' | 'subarray' | 'subId'> & {\n  subarray: Types.DocumentArray<Types.Subdocument>\n}) {\n  const _prev = doc.toJSON(toJSONOptions)\n\n  const subitem = subarray.id(subId)\n\n  if (!subitem) throw httpErrors.notFound(SUBITEM_NOT_FOUND)\n\n  subitem.deleteOne()\n\n  await useSession(\n    Model,\n    req,\n    // @ts-ignore: custom arg req\n    (session?: ClientSession) => doc.save({ req, session, _prev })\n  )\n\n  return subarray.map((subitem) => subitem.toJSON(toJSONOptions))\n}\n", "export const leanOptions = {\n  virtuals: true,\n  versionKey: false,\n}\n\nexport const toJSONOptions = {\n  virtuals: true,\n  versionKey: false,\n}\n\nexport const memoOptions = {\n  maxAge: 30 * 24 * 60 * 60 * 1_000, // 1 month\n}\n\nexport const store = { mongoPath: '' }\n", "import { ClientSession, Model } from 'mongoose'\nimport { FastifyRequest } from 'fastify'\nimport { httpErrors } from '@fastify/sensible'\nimport {\n  DOCUMENT_NOT_FOUND,\n  EMPTY_BODY,\n  INVALID_BODY,\n  SUBARRAY_NOT_FOUND,\n  SUBITEM_NOT_FOUND,\n} from '../mrq.errors'\nimport { model } from './db.utils'\nimport { leanOptions } from '../mrq.config'\nimport { MrqDocument } from '../mrq.interfaces'\nimport fp from 'lodash/fp'\n\ninterface IRunStaticMethods<T> {\n  Model: Model<T>\n  docs: any[]\n  query: { select: { [key: string]: number } }\n  req: FastifyRequest\n}\n\n// ---\n\nexport function runStaticMethods<T>({\n  Model,\n  docs,\n  query,\n  req,\n}: IRunStaticMethods<T>) {\n  for (const staticMethodName in Model.schema.statics) {\n    if (query.select[staticMethodName] !== 1) continue\n\n    for (const doc of docs)\n      doc[staticMethodName] = Model.schema.statics[staticMethodName].call(\n        Model,\n        doc,\n        { req, query }\n      )\n  }\n}\n\n// ---\n\nexport async function useSession(\n  Model: Model<any>,\n  req: FastifyRequest,\n  cb: (session?: ClientSession) => any\n) {\n  const query = req.query as { useSession: string }\n  const shouldUseSession = query.useSession === 'true'\n\n  if (!shouldUseSession) return cb()\n\n  const session = await Model.startSession()\n  const res = await cb(session)\n  session.endSession()\n\n  return res\n}\n\n// ---\n\nexport function getArrayFromBodyWithId(body: any[]) {\n  if (!Array.isArray(body))\n    throw httpErrors.unprocessableEntity(\n      `${INVALID_BODY}: body should be an array`\n    )\n\n  if (!body.length)\n    throw httpErrors.unprocessableEntity(\n      `${EMPTY_BODY}: body should contain at least one object`\n    )\n\n  body = body.filter((doc) => doc._id)\n\n  if (!body.length)\n    throw httpErrors.unprocessableEntity(\n      `${INVALID_BODY}: body should contain at least one object with _id`\n    )\n\n  return body\n}\n\n// ---\n\nexport async function getSubarray(\n  req: FastifyRequest,\n  modelName: string,\n  subPathName_: string,\n  useLean: boolean = false\n): Promise<{ Model: Model<any>; doc: MrqDocument; subarray: any }> {\n  const Model = model(req, modelName)\n\n  const { id } = req.params as { id: string }\n\n  const [subPathName] = subPathName_.split(':')\n\n  const p = Model.findById(id, {}, { req }).select(subPathName)\n\n  const doc: MrqDocument = await (useLean ? p.lean(leanOptions) : p)\n\n  if (!doc) throw httpErrors.notFound(DOCUMENT_NOT_FOUND)\n\n  if (!doc[subPathName]) throw httpErrors.notFound(SUBARRAY_NOT_FOUND)\n\n  return {\n    Model,\n    doc,\n    subarray: doc[subPathName],\n  }\n}\n\n// ---\n\nexport async function getChildarray(\n  req: FastifyRequest,\n  modelName: string,\n  fullPathName: string,\n  useLean: boolean = false\n) {\n  const Model = model(req, modelName)\n\n  const { id, subId } = req.params as { id: string; subId: string }\n\n  const [subPathName, childPathName] = fullPathName.split(':')\n\n  const p = Model.find(\n    {\n      _id: id,\n      [`${subPathName}._id`]: subId,\n    },\n    {},\n    { req }\n  ).select(`\n      ${subPathName}._id\n      ${subPathName}.${childPathName}\n    `)\n\n  const [doc]: any[] = (await (useLean ? p.lean(leanOptions) : p)) ?? []\n\n  if (!doc) throw httpErrors.notFound(DOCUMENT_NOT_FOUND)\n\n  const subitem = fp.find((subitem) => subitem._id.equals(subId), doc[subPathName])\n\n  if (!subitem) throw httpErrors.notFound(SUBITEM_NOT_FOUND)\n\n  return {\n    Model,\n    doc,\n    subitem,\n    subarray: subitem[childPathName],\n  }\n}\n", "export const SCHEMA_NOT_REGISTERED = 'SCHEMA_NOT_REGISTERED'\n\nexport const SESSION_NOT_FOUND = 'SESSION_NOT_FOUND'\n\nexport const IMPLICIT_SELECT_ALL_NOT_ALLOWED = 'IMPLICIT_SELECT_ALL_NOT_ALLOWED'\n\nexport const ROLE_DOES_NOT_HAVE_ACCESS_HOOK_LEVEL =\n  'ROLE_DOES_NOT_HAVE_ACCESS_HOOK_LEVEL'\n\nexport const ROLE_DOES_NOT_HAVE_ACCESS_HANDLER_LEVEL =\n  'ROLE_DOES_NOT_HAVE_ACCESS_HANDLER_LEVEL'\n\nexport const PATH_NOT_FOUND_IN_SCHEMA = 'PATH_NOT_FOUND_IN_SCHEMA'\n\nexport const IMPLICIT_DELETE_ALL_NOT_ALLOWED = 'IMPLICIT_DELETE_ALL_NOT_ALLOWED'\n\nexport const NO_DOCUMENT_FOUND = 'NO_DOCUMENT_FOUND'\n\nexport const INVALID_BODY = 'INVALID_BODY'\n\nexport const EMPTY_BODY = 'EMPTY_BODY'\n\nexport const DOCUMENT_NOT_FOUND = 'DOCUMENT_NOT_FOUND'\n\nexport const SUBARRAY_NOT_FOUND = 'SUBARRAY_NOT_FOUND'\n\nexport const NO_SUBITEM_FOUND = 'NO_SUBITEM_FOUND'\n\nexport const SUBITEM_NOT_FOUND = 'SUBITEM_NOT_FOUND'\n", "import { FastifyInstance, FastifyRequest } from 'fastify'\nimport { httpErrors } from '@fastify/sensible'\nimport { Connection, createConnection, IndexesDiff } from 'mongoose'\nimport fp from 'lodash/fp'\nimport promiseAll from 'promise-all'\nimport { IRestOptions } from '../mrq.interfaces'\nimport { SCHEMA_NOT_REGISTERED } from '../mrq.errors'\nimport { store } from '../mrq.config'\n\nconst pool: { [key: string]: Connection } = {}\n\nlet singleConnection: Connection | null = null\n\nexport async function getSingleConnection(\n  app: FastifyInstance,\n  opts: IRestOptions\n) {\n  if (!store.mongoPath) return\n  singleConnection = await getDB(app, store.mongoPath, opts.schemas)\n}\n\nexport async function getDB(\n  app: FastifyInstance,\n  uri: string,\n  schemas: IRestOptions['schemas']\n) {\n  if (singleConnection) return singleConnection\n\n  let conn: Connection = pool[uri]\n\n  if (!conn) {\n    conn = createConnection(uri, { autoIndex: false })\n\n    await conn.asPromise()\n\n    pool[uri] = conn\n\n    await mapModels(app, conn, schemas)\n  }\n\n  return conn\n}\n\nasync function mapModels(\n  app: FastifyInstance,\n  conn: Connection,\n  schemas: IRestOptions['schemas']\n) {\n  const p: { [modelName: string]: Promise<IndexesDiff> } = {}\n\n  conn.securePathsPerModel = {}\n\n  for (const modelName in schemas) {\n    const { schema } = schemas[modelName]\n\n    if (modelName in conn.models) continue\n\n    const Model = conn.model(modelName, schema)\n\n    p[modelName] = Model.diffIndexes()\n\n    schema.eachPath((path, schemaType) => {\n      if (!conn.securePathsPerModel[modelName])\n        conn.securePathsPerModel[modelName] = {}\n\n      if (schemaType.options.secure)\n        conn.securePathsPerModel[modelName][path] = true\n    })\n  }\n\n  const diffs = await promiseAll(p).then(\n    fp.pickBy<IndexesDiff>((v, k) => v.toDrop.length || v.toCreate.length)\n  )\n\n  const hasAnyDiff = Object.keys(diffs).length\n\n  if (hasAnyDiff)\n    app.log.info('Result of diffIndexes:', JSON.stringify(diffs, null, 2))\n}\n\nexport async function closeConnections() {\n  const p = []\n\n  for (const uri in pool) p.push(pool[uri].close())\n\n  await Promise.allSettled(p)\n}\n\nexport function model(req: FastifyRequest, modelName: string) {\n  const Model = req.mongooseConn.models[modelName]\n\n  if (!Model) throw httpErrors.badRequest(SCHEMA_NOT_REGISTERED)\n\n  return Model\n}\n", "import memoize from 'moize'\nimport { parseFilter } from 'mongodb-query-parser'\nimport { IGetQueryOptions } from '../mrq.interfaces'\nimport { memoOptions } from '../mrq.config'\nimport { getSelect, getSort } from './query.utils'\n\nconst sortMap = {\n  '1': 'asc',\n  '-1': 'desc',\n}\n\nexport const getQueryForSubarray = memoize(getQueryForSubarray_, memoOptions)\n\nfunction getQueryForSubarray_(query: any, options: IGetQueryOptions = {}) {\n  const filterStr =\n    typeof query.filter !== 'string'\n      ? JSON.stringify(query.filter)\n      : query.filter\n\n  const filter = parseFilter(filterStr) ?? {}\n\n  const sort = getSortForSubArray(query.sort)\n\n  const select = getSelectForSubArray(query.select, options)\n\n  const skip = query.skip ? parseInt(query.skip) : 0\n\n  const limit = query.limit ? parseInt(query.limit) : Infinity\n\n  return {\n    filter,\n    sort,\n    select,\n    skip,\n    limit,\n  }\n}\n\nfunction getSelectForSubArray(select: string, options: IGetQueryOptions = {}) {\n  if (options.ignoreSelect) return null\n\n  const selectObject = getSelect(select)\n\n  const selectArr = []\n\n  for (const path in selectObject)\n    if (selectObject[path] === 1) selectArr.push(path)\n\n  if (!selectArr.includes('_id')) selectArr.push('_id')\n\n  return selectArr\n}\n\nfunction getSortForSubArray(sort: string) {\n  const sortObject: { [key: string]: '1' | '-1' } = getSort(sort)\n\n  const sortFieldsArr = []\n  const sortOrderArr = []\n\n  for (const sortField in sortObject) {\n    sortFieldsArr.push(sortField)\n    sortOrderArr.push(sortMap[sortObject[sortField] as keyof typeof sortMap])\n  }\n\n  return {\n    sortFieldsArr,\n    sortOrderArr,\n  }\n}\n", "import memoize from 'moize'\nimport { FastifyRequest } from 'fastify'\nimport { httpErrors } from '@fastify/sensible'\nimport { parseFilter, parseSort, parseProject } from 'mongodb-query-parser'\nimport { IMPLICIT_SELECT_ALL_NOT_ALLOWED } from '../mrq.errors'\nimport { IGetQueryOptions, MrqQuery } from '../mrq.interfaces'\nimport { memoOptions } from '../mrq.config'\n\ntype TypeSecurePaths = { [path: string]: boolean }\n\nexport function getQuery(\n  req: FastifyRequest,\n  modelName: string,\n  options: IGetQueryOptions = {}\n) {\n  const securePaths = req.mongooseConn.securePathsPerModel[modelName]\n\n  return getQueryInternal(req.query, securePaths, options)\n}\n\nconst getQueryInternal = memoize(getQueryInternal_, memoOptions)\n\nfunction getQueryInternal_(\n  query: any,\n  securePaths: TypeSecurePaths,\n  options: IGetQueryOptions = {}\n): MrqQuery {\n  const filter = getFilter(query.filter)\n\n  const sort = getSort(query.sort)\n\n  const select = getSelect(query.select, securePaths, options)\n\n  const populate = getPopulate(query.populate)\n\n  const skip = query.skip ? parseInt(query.skip) : 0\n\n  const limit = query.limit ? parseInt(query.limit) : 0\n\n  return {\n    filter,\n    sort,\n    select,\n    populate,\n    skip,\n    limit,\n  }\n}\n\nfunction getFilter(filter: string) {\n  const filterStr = typeof filter !== 'string' ? JSON.stringify(filter) : filter\n\n  return parseFilter(filterStr) ?? {}\n}\n\nexport function getSort(fields: string) {\n  if (!fields) return {}\n\n  const sort: Record<string, 1 | -1> = {}\n\n  const fieldList = fields.split(',').map((str) => str.trim())\n\n  for (const field of fieldList) {\n    if (field.startsWith('-')) sort[field.slice(1)] = -1\n    else sort[field] = 1\n  }\n\n  return parseSort(JSON.stringify(sort))\n}\n\nexport function getSelect(\n  fields: string = '',\n  securePaths: TypeSecurePaths = {},\n  options: IGetQueryOptions = {}\n) {\n  if (options.ignoreSelect) return {}\n\n  const select: Record<string, 1 | 0> = {}\n\n  const fieldList = fields\n    .split(',')\n    .map((str) => str.trim())\n    .filter(Boolean)\n\n  if (!fieldList.length)\n    throw httpErrors.methodNotAllowed(\n      `${IMPLICIT_SELECT_ALL_NOT_ALLOWED}: use select=all query param`\n    )\n\n  if (fieldList.includes('all'))\n    return transformSecurePathsToSelect(securePaths)\n\n  for (const field of fieldList) {\n    if (securePaths[field]) continue\n\n    if (field.startsWith('-')) select[field.slice(1)] = 0\n    else select[field] = 1\n  }\n\n  return parseProject(JSON.stringify(select))\n}\n\nfunction transformSecurePathsToSelect(securePaths: TypeSecurePaths) {\n  const select: Record<string, 1 | 0> = {}\n\n  for (const [path, value] of Object.entries(securePaths)) {\n    if (value) select[path] = 0\n  }\n\n  return select\n}\n\nfunction getPopulate(populate: string): any {\n  return parsePopulate(populate)\n}\n\nfunction parsePopulate(populate: string) {\n  try {\n    const parsed = JSON.parse(populate)\n\n    if (typeof parsed !== 'object') throw 1\n\n    // Sanitize normally is being done in parseFilter\n    return parseFilter(JSON.stringify(parsed))\n  } catch (e) {\n    return populate\n  }\n}\n"],
  "mappings": "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",
  "names": ["import_sensible", "import_fp", "import_sensible", "import_fp", "import_sensible", "fp", "sift", "subitem", "import_moize", "import_mongodb_query_parser", "import_sensible", "memoize", "memoize", "getByQuery", "count", "distinct", "create", "updateMany", "deleteByQuery", "getById", "updateById", "deleteById"]
}
