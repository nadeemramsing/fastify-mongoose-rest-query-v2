{
  "version": 3,
  "sources": ["../../src/handler/main.handler.ts", "../../src/utils/db.utils.ts", "../../src/mrq.errors.ts", "../../src/mrq.config.ts", "../../src/utils/query.utils.ts", "../../src/mrq.enum.ts", "../../src/utils/mongoose.utils.ts"],
  "sourcesContent": ["import { RouteHandlerMethod } from 'fastify'\nimport { httpErrors } from '@fastify/sensible'\nimport { ClientSession, Document } from 'mongoose'\nimport { model } from '../utils/db.utils'\nimport { leanOptions, toJSONOptions } from '../mrq.config'\nimport { getQuery } from '../utils/query.utils'\nimport { HandlerAccessEnum } from '../mrq.enum'\nimport {\n  getArrayFromBodyWithId,\n  runStaticMethods,\n  useSession,\n} from '../utils/mongoose.utils'\nimport {\n  DOCUMENT_NOT_FOUND,\n  IMPLICIT_DELETE_ALL_NOT_ALLOWED,\n  INVALID_BODY,\n  NO_DOCUMENT_FOUND,\n  PATH_NOT_FOUND_IN_SCHEMA,\n  ROLE_DOES_NOT_HAVE_ACCESS_HANDLER_LEVEL,\n} from '../mrq.errors'\n\nexport const getMainHandler = (\n  modelName: string,\n  handlerAccesses: HandlerAccessEnum[] = []\n) => {\n  const getByQuery: RouteHandlerMethod = async (req, rep) => {\n    if (!handlerAccesses.includes(HandlerAccessEnum.GET_BY_QUERY))\n      throw httpErrors.unauthorized(ROLE_DOES_NOT_HAVE_ACCESS_HANDLER_LEVEL)\n\n    const Model = model(req, modelName)\n\n    const query = getQuery(req, modelName)\n\n    const docs = await Model.find(query.filter, query.select, { req })\n      .populate(query.populate)\n      .sort(query.sort)\n      .collation({ locale: 'simple', caseLevel: true })\n      .limit(query.limit)\n      .skip(query.skip)\n      .lean(leanOptions)\n\n    runStaticMethods({ Model, docs, query, req })\n\n    return docs\n  }\n\n  // ---\n\n  const count: RouteHandlerMethod = async (req, rep) => {\n    if (!handlerAccesses.includes(HandlerAccessEnum.COUNT))\n      throw httpErrors.unauthorized(ROLE_DOES_NOT_HAVE_ACCESS_HANDLER_LEVEL)\n\n    const Model = model(req, modelName)\n\n    const query = getQuery(req, modelName, { ignoreSelect: true })\n\n    return { n: await Model.countDocuments(query.filter) }\n  }\n\n  // ---\n\n  const distinct: RouteHandlerMethod = async (req, rep) => {\n    if (!handlerAccesses.includes(HandlerAccessEnum.DISTINCT))\n      throw httpErrors.unauthorized(ROLE_DOES_NOT_HAVE_ACCESS_HANDLER_LEVEL)\n\n    const params = req.params as { path: string }\n\n    const Model = model(req, modelName)\n\n    const doesPathExists = Model.schema.path(params.path)\n\n    if (!doesPathExists) throw httpErrors.notFound(PATH_NOT_FOUND_IN_SCHEMA)\n\n    const query = getQuery(req, modelName, { ignoreSelect: true })\n\n    return Model.distinct(params.path, query.filter)\n  }\n\n  // ---\n\n  const create: RouteHandlerMethod = async (req, rep) => {\n    if (!handlerAccesses.includes(HandlerAccessEnum.CREATE))\n      throw httpErrors.unauthorized(ROLE_DOES_NOT_HAVE_ACCESS_HANDLER_LEVEL)\n\n    const Model = model(req, modelName)\n\n    let body: any = req.body\n\n    const isBodyAnArray = Array.isArray(body)\n\n    if (isBodyAnArray && !body.length)\n      throw httpErrors.notFound(`${INVALID_BODY}: no object found in array`)\n\n    if (!isBodyAnArray) body = [body]\n\n    const docs = await useSession(Model, req, (session?: ClientSession) =>\n      Model.create(body, { req, session, ordered: !!session })\n    )\n\n    const result = docs.map((doc: any) => doc.toJSON(toJSONOptions))\n\n    return isBodyAnArray ? result : result[0]\n  }\n\n  // ---\n\n  const updateMany: RouteHandlerMethod = async (req, rep) => {\n    if (!handlerAccesses.includes(HandlerAccessEnum.UPDATE_MANY))\n      throw httpErrors.unauthorized(ROLE_DOES_NOT_HAVE_ACCESS_HANDLER_LEVEL)\n\n    const Model = model(req, modelName)\n\n    const body = getArrayFromBodyWithId(req.body as any[])\n\n    const _id = { $in: body.map((item: any) => item._id) }\n\n    const docs: Record<string, Document> = await Model.find({ _id }).then(\n      (docs) => docs.reduce((acc, v: any) => ({ ...acc, [v._id]: v }), {})\n    )\n\n    //@ts-ignore\n    req.query.useSession = 'true'\n\n    const docsSaved: Document[] = []\n\n    const isOverwrite = req.routeOptions.url?.endsWith?.('/overwrite')\n\n    await useSession(Model, req, async (session?: ClientSession) => {\n      for (const item of body) {\n        const doc = docs[item._id]\n\n        const _prev = doc.toJSON(toJSONOptions)\n\n        isOverwrite ? doc.overwrite(item) : doc.set(item)\n\n        // @ts-ignore: custom arg req\n        docsSaved.push(await doc.save({ req, session, _prev }))\n      }\n    })\n\n    return docsSaved\n  }\n\n  // ---\n\n  const deleteByQuery: RouteHandlerMethod = async (req, rep) => {\n    if (!handlerAccesses.includes(HandlerAccessEnum.DELETE_BY_QUERY))\n      throw httpErrors.unauthorized(ROLE_DOES_NOT_HAVE_ACCESS_HANDLER_LEVEL)\n\n    const Model = model(req, modelName)\n\n    const query = getQuery(req, modelName, { ignoreSelect: true })\n\n    const isDeleteAll = !Object.keys(query.filter).length\n\n    if (isDeleteAll)\n      throw httpErrors.methodNotAllowed(\n        `${IMPLICIT_DELETE_ALL_NOT_ALLOWED}: delete directly in database`\n      )\n\n    const { deletedCount } = await useSession(\n      Model,\n      req,\n      (session?: ClientSession) => Model.deleteMany(query.filter, { session })\n    )\n\n    if (!deletedCount) throw httpErrors.notFound(NO_DOCUMENT_FOUND)\n\n    return { deletedCount }\n  }\n\n  // ---\n\n  const getById: RouteHandlerMethod = async (req, rep) => {\n    if (!handlerAccesses.includes(HandlerAccessEnum.GET_BY_ID))\n      throw httpErrors.unauthorized(ROLE_DOES_NOT_HAVE_ACCESS_HANDLER_LEVEL)\n\n    const Model = model(req, modelName)\n\n    const { id } = req.params as { id: string }\n\n    const query = getQuery(req, modelName)\n\n    const doc = await Model.findById(id, query.select, { req })\n      .and(query.filter)\n      .populate(query.populate)\n      .lean(leanOptions)\n\n    if (!doc) throw httpErrors.notFound(DOCUMENT_NOT_FOUND)\n\n    runStaticMethods({ Model, docs: [doc], query, req })\n\n    return doc\n  }\n\n  // ---\n\n  const updateById: RouteHandlerMethod = async (req, rep) => {\n    if (!handlerAccesses.includes(HandlerAccessEnum.UPDATE_BY_ID))\n      throw httpErrors.unauthorized(ROLE_DOES_NOT_HAVE_ACCESS_HANDLER_LEVEL)\n\n    const Model = model(req, modelName)\n\n    const { id } = req.params as { id: string }\n\n    const doc = await Model.findById(id)\n\n    if (!doc) throw httpErrors.notFound(DOCUMENT_NOT_FOUND)\n\n    const _prev = doc.toJSON(toJSONOptions)\n\n    req.routeOptions.url?.endsWith?.('/overwrite')\n      ? doc.overwrite(req.body)\n      : doc.set(req.body)\n\n    await useSession(\n      Model,\n      req,\n      // @ts-ignore: custom arg req\n      (session: ClientSession) => doc.save({ req, session, _prev })\n    )\n\n    return doc.toJSON(toJSONOptions)\n  }\n\n  // ---\n\n  const deleteById: RouteHandlerMethod = async (req, rep) => {\n    if (!handlerAccesses.includes(HandlerAccessEnum.DELETE_BY_ID))\n      throw httpErrors.unauthorized(ROLE_DOES_NOT_HAVE_ACCESS_HANDLER_LEVEL)\n\n    const Model = model(req, modelName)\n\n    const { id: _id } = req.params as { id: string }\n\n    const { deletedCount } = await useSession(\n      Model,\n      req,\n      (session?: ClientSession) => Model.deleteOne({ _id }, { session })\n    )\n\n    if (!deletedCount) throw httpErrors.notFound(DOCUMENT_NOT_FOUND)\n\n    return { deletedCount }\n  }\n\n  return {\n    getByQuery,\n    count,\n    distinct,\n    create,\n    updateMany,\n    deleteByQuery,\n\n    getById,\n    updateById,\n    deleteById,\n  }\n}\n", "import { FastifyInstance, FastifyRequest } from 'fastify'\nimport { httpErrors } from '@fastify/sensible'\nimport { Connection, createConnection, IndexesDiff } from 'mongoose'\nimport fp from 'lodash/fp'\nimport promiseAll from 'promise-all'\nimport { IModelToSchemaMap } from '../mrq.interfaces'\nimport { SCHEMA_NOT_REGISTERED } from '../mrq.errors'\nimport { store } from '../mrq.config'\n\nlet connGlobal: Connection\n\nexport async function initConnection() {\n  const mongoUrl = `${store.mongoBaseUrl}/${store.mongoDatabaseName ?? ''}`\n\n  connGlobal = await createConnection(mongoUrl, {\n    autoIndex: false,\n    auth: {\n      username: store.mongoUser,\n      password: store.mongoPassword,\n    },\n    authSource: store.mongoAdminSource,\n    minPoolSize: store.mongoMinPoolSize,\n    maxPoolSize: store.mongoMaxPoolSize,\n    replicaSet: store.mongoReplicaSet || undefined,\n  }).asPromise()\n}\n\nexport async function getDB(\n  app: FastifyInstance,\n  databaseName: string,\n  schemas: IModelToSchemaMap\n) {\n  let connDB: Connection\n\n  if (store.mongoDatabaseName) connDB = connGlobal\n  else\n    connDB = await connGlobal\n      .useDb(databaseName, { useCache: true })\n      .asPromise()\n\n  if (!connDB.get('hasMapModelsBeenCalled'))\n    await mapModels(app, connDB, schemas)\n\n  return connDB\n}\n\nasync function mapModels(\n  app: FastifyInstance,\n  connDB: Connection,\n  schemas: IModelToSchemaMap\n) {\n  connDB.set('hasMapModelsBeenCalled', true)\n\n  const p: { [modelName: string]: Promise<IndexesDiff> } = {}\n\n  connDB.securePathsPerModel = {}\n\n  for (const modelName in schemas) {\n    const schema = schemas[modelName]\n\n    if (modelName in connDB.models) continue\n\n    const Model = connDB.model(modelName, schema)\n\n    p[modelName] = Model.diffIndexes()\n\n    schema.eachPath((path, schemaType) => {\n      if (!connDB.securePathsPerModel[modelName])\n        connDB.securePathsPerModel[modelName] = {}\n\n      if (schemaType.options.secure)\n        connDB.securePathsPerModel[modelName][path] = true\n    })\n  }\n\n  const diffs = await promiseAll(p).then(\n    fp.pickBy<IndexesDiff>((v, k) => v.toDrop.length || v.toCreate.length)\n  )\n\n  const hasAnyDiff = Object.keys(diffs).length\n\n  if (hasAnyDiff)\n    app.log.info('Result of diffIndexes:', JSON.stringify(diffs, null, 2))\n}\n\nexport async function closeConnections() {\n  await connGlobal.close()\n}\n\nexport function model(req: FastifyRequest, modelName: string) {\n  const Model = req.mongooseConn.models[modelName]\n\n  if (!Model) throw httpErrors.badRequest(SCHEMA_NOT_REGISTERED)\n\n  return Model\n}\n", "export const SCHEMA_NOT_REGISTERED = 'SCHEMA_NOT_REGISTERED'\n\nexport const SESSION_NOT_FOUND = 'SESSION_NOT_FOUND'\n\nexport const IMPLICIT_SELECT_ALL_NOT_ALLOWED = 'IMPLICIT_SELECT_ALL_NOT_ALLOWED'\n\nexport const ROLE_DOES_NOT_HAVE_ACCESS_HOOK_LEVEL =\n  'ROLE_DOES_NOT_HAVE_ACCESS_HOOK_LEVEL'\n\nexport const ROLE_DOES_NOT_HAVE_ACCESS_HANDLER_LEVEL =\n  'ROLE_DOES_NOT_HAVE_ACCESS_HANDLER_LEVEL'\n\nexport const PATH_NOT_FOUND_IN_SCHEMA = 'PATH_NOT_FOUND_IN_SCHEMA'\n\nexport const IMPLICIT_DELETE_ALL_NOT_ALLOWED = 'IMPLICIT_DELETE_ALL_NOT_ALLOWED'\n\nexport const NO_DOCUMENT_FOUND = 'NO_DOCUMENT_FOUND'\n\nexport const INVALID_BODY = 'INVALID_BODY'\n\nexport const EMPTY_BODY = 'EMPTY_BODY'\n\nexport const DOCUMENT_NOT_FOUND = 'DOCUMENT_NOT_FOUND'\n\nexport const SUBARRAY_NOT_FOUND = 'SUBARRAY_NOT_FOUND'\n\nexport const NO_SUBITEM_FOUND = 'NO_SUBITEM_FOUND'\n\nexport const SUBITEM_NOT_FOUND = 'SUBITEM_NOT_FOUND'\n", "export const leanOptions = {\n  virtuals: true,\n  versionKey: false,\n}\n\nexport const toJSONOptions = {\n  virtuals: true,\n  versionKey: false,\n}\n\nexport const memoOptions = {\n  maxAge: 24 * 24 * 60 * 60 * 1_000, // 24 days\n}\n\nexport const store = {\n  alwaysUseSession: false,\n  mongoDatabaseName: '',\n  mongoUser: '',\n  mongoPassword: '',\n  mongoBaseUrl: 'mongodb://localhost:27016',\n  mongoAdminSource: 'admin',\n  mongoMinPoolSize: 2,\n  mongoMaxPoolSize: 20,\n  mongoReplicaSet: ''\n}\n", "import memoize from 'moize'\nimport { FastifyRequest } from 'fastify'\nimport { httpErrors } from '@fastify/sensible'\nimport { parseFilter, parseSort, parseProject } from 'mongodb-query-parser'\nimport { IMPLICIT_SELECT_ALL_NOT_ALLOWED } from '../mrq.errors'\nimport { IGetQueryOptions, MrqQuery } from '../mrq.interfaces'\nimport { memoOptions } from '../mrq.config'\n\ntype TypeSecurePaths = { [path: string]: boolean }\n\nexport function getQuery(\n  req: FastifyRequest,\n  modelName: string,\n  options: IGetQueryOptions = {}\n) {\n  const securePaths = req.mongooseConn.securePathsPerModel[modelName]\n\n  return getQueryInternal(req.query, securePaths, options)\n}\n\nconst getQueryInternal = memoize(getQueryInternal_, memoOptions)\n\nfunction getQueryInternal_(\n  query: any,\n  securePaths: TypeSecurePaths,\n  options: IGetQueryOptions = {}\n): MrqQuery {\n  const filter = getFilter(query.filter)\n\n  const sort = getSort(query.sort)\n\n  const select = getSelect(query.select, securePaths, options)\n\n  const populate = getPopulate(query.populate)\n\n  const skip = query.skip ? parseInt(query.skip) : 0\n\n  const limit = query.limit ? parseInt(query.limit) : 0\n\n  return {\n    filter,\n    sort,\n    select,\n    populate,\n    skip,\n    limit,\n  }\n}\n\nfunction getFilter(filter: string) {\n  const filterStr = typeof filter !== 'string' ? JSON.stringify(filter) : filter\n\n  return parseFilter(filterStr) ?? {}\n}\n\nexport function getSort(fields: string) {\n  if (!fields) return {}\n\n  const sort: Record<string, 1 | -1> = {}\n\n  const fieldList = fields.split(',').map((str) => str.trim())\n\n  for (const field of fieldList) {\n    if (field.startsWith('-')) sort[field.slice(1)] = -1\n    else sort[field] = 1\n  }\n\n  return parseSort(JSON.stringify(sort))\n}\n\nexport function getSelect(\n  fields: string = '',\n  securePaths: TypeSecurePaths = {},\n  options: IGetQueryOptions = {}\n) {\n  if (options.ignoreSelect) return {}\n\n  const select: Record<string, 1 | 0> = {}\n\n  const fieldList = fields\n    .split(',')\n    .map((str) => str.trim())\n    .filter(Boolean)\n\n  if (!fieldList.length)\n    throw httpErrors.methodNotAllowed(\n      `${IMPLICIT_SELECT_ALL_NOT_ALLOWED}: use select=all query param`\n    )\n\n  if (fieldList.includes('all'))\n    return transformSecurePathsToSelect(securePaths)\n\n  for (const field of fieldList) {\n    if (securePaths[field]) continue\n\n    if (field.startsWith('-')) select[field.slice(1)] = 0\n    else select[field] = 1\n  }\n\n  return parseProject(JSON.stringify(select))\n}\n\nfunction transformSecurePathsToSelect(securePaths: TypeSecurePaths) {\n  const select: Record<string, 1 | 0> = {}\n\n  for (const [path, value] of Object.entries(securePaths)) {\n    if (value) select[path] = 0\n  }\n\n  return select\n}\n\nfunction getPopulate(populate: string): any {\n  return parsePopulate(populate)\n}\n\nfunction parsePopulate(populate: string) {\n  try {\n    const parsed = JSON.parse(populate)\n\n    if (typeof parsed !== 'object') throw 1\n\n    // Sanitize normally is being done in parseFilter\n    return parseFilter(JSON.stringify(parsed))\n  } catch (e) {\n    return populate\n  }\n}\n", "export enum HandlerAccessEnum {\n  // MAIN\n  CREATE_INDEX = 'CREATE_INDEX',\n  GET_BY_QUERY = 'GET_BY_QUERY',\n  COUNT = 'COUNT',\n  DISTINCT = 'DISTINCT',\n  CREATE = 'CREATE',\n  DELETE_BY_QUERY = 'DELETE_BY_QUERY',\n  UPDATE_MANY = 'UPDATE_MANY',\n\n  // MAIN WITH ID\n  GET_BY_ID = 'GET_BY_ID',\n  UPDATE_BY_ID = 'UPDATE_BY_ID',\n  DELETE_BY_ID = 'DELETE_BY_ID',\n\n  // SUB\n  GET_BY_QUERY_SUB = 'GET_BY_QUERY_SUB',\n  COUNT_SUB = 'COUNT_SUB',\n  DISTINCT_SUB = 'DISTINCT_SUB',\n  CREATE_SUB = 'CREATE_SUB',\n  UPDATE_MANY_SUB = 'UPDATE_MANY_SUB',\n  DELETE_BY_QUERY_SUB = 'DELETE_BY_QUERY_SUB',\n\n  // SUB WITH ID\n  GET_BY_ID_SUB = 'GET_BY_ID_SUB',\n  UPDATE_BY_ID_SUB = 'UPDATE_BY_ID_SUB',\n  DELETE_BY_ID_SUB = 'DELETE_BY_ID_SUB',\n}\n\nexport const ALL_GET = [\n  HandlerAccessEnum.GET_BY_QUERY,\n  HandlerAccessEnum.GET_BY_QUERY_SUB,\n  HandlerAccessEnum.GET_BY_ID,\n  HandlerAccessEnum.GET_BY_ID_SUB,\n  HandlerAccessEnum.COUNT,\n  HandlerAccessEnum.COUNT_SUB,\n  HandlerAccessEnum.DISTINCT,\n  HandlerAccessEnum.DISTINCT_SUB,\n]\n\nexport const ALL_POST = [HandlerAccessEnum.CREATE, HandlerAccessEnum.CREATE_SUB]\n\nexport const ALL_PUT = [\n  HandlerAccessEnum.UPDATE_MANY,\n  HandlerAccessEnum.UPDATE_MANY_SUB,\n  HandlerAccessEnum.UPDATE_BY_ID,\n  HandlerAccessEnum.UPDATE_BY_ID_SUB,\n]\n\nexport const ALL_DELETE = [\n  HandlerAccessEnum.DELETE_BY_QUERY,\n  HandlerAccessEnum.DELETE_BY_QUERY_SUB,\n  HandlerAccessEnum.DELETE_BY_ID,\n  HandlerAccessEnum.DELETE_BY_ID_SUB,\n]\n\nexport const ALL_HANDLERS = [...ALL_GET, ...ALL_POST, ...ALL_PUT, ...ALL_DELETE]\n", "import { ClientSession, Model } from 'mongoose'\nimport { FastifyRequest } from 'fastify'\nimport { httpErrors } from '@fastify/sensible'\nimport {\n  DOCUMENT_NOT_FOUND,\n  EMPTY_BODY,\n  INVALID_BODY,\n  SUBARRAY_NOT_FOUND,\n  SUBITEM_NOT_FOUND,\n} from '../mrq.errors'\nimport { model } from './db.utils'\nimport { leanOptions, store } from '../mrq.config'\nimport { MrqDocument } from '../mrq.interfaces'\nimport fp from 'lodash/fp'\n\ninterface IRunStaticMethods<T> {\n  Model: Model<T>\n  docs: any[]\n  query: { select: { [key: string]: number } }\n  req: FastifyRequest\n}\n\n// ---\n\nexport function runStaticMethods<T>({\n  Model,\n  docs,\n  query,\n  req,\n}: IRunStaticMethods<T>) {\n  for (const staticMethodName in Model.schema.statics) {\n    if (query.select[staticMethodName] !== 1) continue\n\n    for (const doc of docs)\n      doc[staticMethodName] = Model.schema.statics[staticMethodName].call(\n        Model,\n        doc,\n        { req, query }\n      )\n  }\n}\n\n// ---\n\nexport async function useSession(\n  Model: Model<any>,\n  req: FastifyRequest,\n  cb: (session?: ClientSession) => any\n) {\n  const query = req.query as { useSession: string }\n  const shouldUseSession = store.alwaysUseSession || query.useSession === 'true'\n\n  if (!shouldUseSession) return cb()\n\n  const session = await Model.startSession()\n  const res = await cb(session)\n  session.endSession()\n\n  return res\n}\n\n// ---\n\nexport function getArrayFromBodyWithId(body: any[]) {\n  if (!Array.isArray(body))\n    throw httpErrors.unprocessableEntity(\n      `${INVALID_BODY}: body should be an array`\n    )\n\n  if (!body.length)\n    throw httpErrors.unprocessableEntity(\n      `${EMPTY_BODY}: body should contain at least one object`\n    )\n\n  body = body.filter((doc) => doc._id)\n\n  if (!body.length)\n    throw httpErrors.unprocessableEntity(\n      `${INVALID_BODY}: body should contain at least one object with _id`\n    )\n\n  return body\n}\n\n// ---\n\nexport async function getSubarray(\n  req: FastifyRequest,\n  modelName: string,\n  subPathName_: string,\n  useLean: boolean = false\n): Promise<{ Model: Model<any>; doc: MrqDocument; subarray: any }> {\n  const Model = model(req, modelName)\n\n  const { id } = req.params as { id: string }\n\n  const [subPathName] = subPathName_.split(':')\n\n  const p = Model.findById(id, {}, { req }).select(subPathName)\n\n  const doc: MrqDocument = await (useLean ? p.lean(leanOptions) : p)\n\n  if (!doc) throw httpErrors.notFound(DOCUMENT_NOT_FOUND)\n\n  if (!doc[subPathName]) throw httpErrors.notFound(SUBARRAY_NOT_FOUND)\n\n  return {\n    Model,\n    doc,\n    subarray: doc[subPathName],\n  }\n}\n\n// ---\n\nexport async function getChildarray(\n  req: FastifyRequest,\n  modelName: string,\n  fullPathName: string,\n  useLean: boolean = false\n) {\n  const Model = model(req, modelName)\n\n  const { id, subId } = req.params as { id: string; subId: string }\n\n  const [subPathName, childPathName] = fullPathName.split(':')\n\n  const p = Model.find(\n    {\n      _id: id,\n      [`${subPathName}._id`]: subId,\n    },\n    {},\n    { req }\n  ).select(`\n      ${subPathName}._id\n      ${subPathName}.${childPathName}\n    `)\n\n  const [doc]: any[] = (await (useLean ? p.lean(leanOptions) : p)) ?? []\n\n  if (!doc) throw httpErrors.notFound(DOCUMENT_NOT_FOUND)\n\n  const subitem = fp.find(\n    (subitem) => subitem._id.equals(subId),\n    doc[subPathName]\n  )\n\n  if (!subitem) throw httpErrors.notFound(SUBITEM_NOT_FOUND)\n\n  return {\n    Model,\n    doc,\n    subitem,\n    subarray: subitem[childPathName],\n  }\n}\n"],
  "mappings": "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",
  "names": ["import_sensible", "import_sensible", "memoize", "import_sensible", "import_fp", "docs"]
}
