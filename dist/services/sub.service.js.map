{
  "version": 3,
  "sources": ["../../src/services/sub.service.ts", "../../src/mrq.config.ts", "../../src/utils/mongoose.utils.ts", "../../src/mrq.errors.ts", "../../src/utils/db.utils.ts"],
  "sourcesContent": ["import { ObjectId } from 'bson'\nimport { Model, Types } from 'mongoose'\nimport { FastifyRequest } from 'fastify'\nimport fp from 'lodash/fp'\nimport sift from 'sift'\nimport { MrqDocument, MrqQuery } from '../mrq.interfaces'\nimport { toJSONOptions } from '../mrq.config'\nimport { useSession } from '../utils/mongoose.utils'\nimport { httpErrors } from '@fastify/sensible'\nimport {\n  IMPLICIT_DELETE_ALL_NOT_ALLOWED,\n  NO_SUBITEM_FOUND,\n  SUBITEM_NOT_FOUND,\n} from '../mrq.errors'\n\ninterface IBaseOptions {\n  body: any\n  doc: MrqDocument\n  query: Omit<MrqQuery, 'populate'>\n  Model: Model<any>\n  path: string\n  req: FastifyRequest\n  subarray: any[] | Types.DocumentArray<Types.Subdocument>\n  subId: string\n}\n\nexport async function getByQuery({\n  query,\n  subarray,\n}: Pick<IBaseOptions, 'query' | 'subarray'>) {\n  return fp.pipe(\n    fp.filter(sift(query.filter)),\n    query.sort.sortFieldsArr.length\n      ? fp.orderBy(query.sort.sortFieldsArr, query.sort.sortOrderArr)\n      : (x) => x,\n    fp.drop(query.skip),\n    fp.take(query.limit),\n    fp.map(query.select.length > 1 ? fp.pick(query.select) : (x) => x)\n  )(subarray)\n}\n\n// ---\n\nexport async function count({\n  query,\n  subarray,\n}: Pick<IBaseOptions, 'query' | 'subarray'>) {\n  return fp.pipe(fp.filter(sift(query.filter)), fp.size)(subarray)\n}\n\n// ---\n\nexport async function distinct({\n  query,\n  path,\n  subarray,\n}: Pick<IBaseOptions, 'query' | 'path' | 'subarray'>) {\n  return fp.pipe(\n    fp.filter(sift(query.filter)),\n    fp.pluck(path),\n    fp.uniq,\n    fp.reject(fp.isNil)\n  )(subarray)\n}\n\n// ---\n\nexport async function create({\n  body,\n  doc,\n  Model,\n  req,\n  subarray,\n}: Pick<IBaseOptions, 'body' | 'doc' | 'Model' | 'req' | 'subarray'>) {\n  const _prev = doc.toJSON(toJSONOptions)\n\n  const idsMap = body\n    .map((item: any) => ((item._id = item._id ?? new ObjectId()), item))\n    .reduce((acc: {}, v: any) => ({ ...acc, [v._id]: true }), {})\n\n  for (const item of body) subarray.push(item)\n\n  await useSession(\n    Model,\n    req,\n    // @ts-ignore: custom arg req\n    (session?: ClientSession) => doc.save({ req, session, _prev })\n  )\n\n  const subarraySaved = subarray.map((subitem) => subitem.toJSON(toJSONOptions))\n\n  const query = req.query as { returnAll: string }\n  const shouldReturnAll = query.returnAll === 'true'\n\n  if (shouldReturnAll) return subarraySaved\n\n  return subarraySaved.filter((subitem) => idsMap[subitem._id])\n}\n\n// ---\n\nexport async function updateMany({\n  body,\n  doc,\n  Model,\n  req,\n  subarray,\n}: Pick<IBaseOptions, 'body' | 'doc' | 'Model' | 'req' | 'subarray'> & {\n  subarray: Types.DocumentArray<Types.Subdocument>\n}) {\n  const _prev = doc.toJSON(toJSONOptions)\n\n  const bodyIdsMap = body.reduce(\n    (acc: {}, v: any) => ({ ...acc, [v._id]: true }),\n    {}\n  )\n\n  const [subitemsToUpdate, subitemsToNotUpdate] = fp.partition(\n    (subitem) => bodyIdsMap[subitem._id],\n    subarray\n  )\n\n  for (const item of body) {\n    const subitem = subarray.id(item._id)\n\n    if (!subitem) continue\n\n    subitem.set(item)\n  }\n\n  if (req.routeOptions.url?.endsWith?.('/overwrite'))\n    for (const subitem of subitemsToNotUpdate) subitem.deleteOne()\n\n  await useSession(\n    Model,\n    req,\n    // @ts-ignore: custom arg req\n    (session?: ClientSession) => doc.save({ req, session, _prev })\n  )\n\n  const query = req.query as { returnAll: string }\n  const shouldReturnAll = query.returnAll === 'true'\n\n  return shouldReturnAll\n    ? subarray.map((subitem) => subitem.toJSON(toJSONOptions))\n    : subitemsToUpdate.map((subitem) => subitem.toJSON(toJSONOptions))\n}\n\n// ---\n\nexport async function deleteByQuery({\n  doc,\n  query,\n  Model,\n  req,\n  subarray,\n}: Pick<IBaseOptions, 'doc' | 'query' | 'Model' | 'req' | 'subarray'> & {\n  subarray: Types.DocumentArray<Types.Subdocument>\n}) {\n  const isDeleteAll = !Object.keys(query.filter).length\n\n  if (isDeleteAll)\n    throw httpErrors.methodNotAllowed(IMPLICIT_DELETE_ALL_NOT_ALLOWED)\n\n  const subarrayToDelete = fp.filter(\n    sift(query.filter),\n    subarray\n  ) as Types.DocumentArray<Types.Subdocument>\n\n  if (subarrayToDelete.length === 0) throw httpErrors.notFound(NO_SUBITEM_FOUND)\n\n  const _prev = doc.toJSON(toJSONOptions)\n\n  for (const subitem of subarrayToDelete) subitem.deleteOne()\n\n  await useSession(\n    Model,\n    req,\n    // @ts-ignore: custom arg req\n    (session?: ClientSession) => doc.save({ req, session, _prev })\n  )\n\n  return subarray.map((subitem) => subitem.toJSON(toJSONOptions))\n}\n\n// ---\n\nexport async function getById({\n  query,\n  subarray,\n  subId,\n}: Pick<IBaseOptions, 'query' | 'subarray' | 'subId'>) {\n  const subitem = fp.pipe(\n    fp.find((subitem: { _id: ObjectId }) => subitem._id.equals(subId)),\n    query.select.length > 1 ? fp.pick(query.select) : (x) => x\n  )(subarray)\n\n  if (!subitem || !Object.keys(subitem).length)\n    throw httpErrors.notFound(SUBITEM_NOT_FOUND)\n\n  return subitem\n}\n\n// ---\n\nexport async function updateById({\n  body,\n  doc,\n  Model,\n  req,\n  subarray,\n  subId,\n}: Pick<\n  IBaseOptions,\n  'body' | 'doc' | 'Model' | 'req' | 'subarray' | 'subId'\n> & {\n  subarray: Types.DocumentArray<Types.Subdocument>\n}) {\n  const _prev = doc.toJSON(toJSONOptions)\n\n  const subitem = subarray.id(subId)\n\n  if (!subitem) throw httpErrors.notFound(SUBITEM_NOT_FOUND)\n\n  if (req.routeOptions.url?.endsWith?.('/overwrite')) subitem.overwrite(body)\n  else subitem.set(body)\n\n  await useSession(\n    Model,\n    req,\n    // @ts-ignore: custom arg req\n    (session?: ClientSession) => doc.save({ req, session, _prev })\n  )\n\n  const query = req.query as { returnAll: string }\n  const shouldReturnAll = query.returnAll === 'true'\n\n  return shouldReturnAll\n    ? subarray.map((subitem) => subitem.toJSON(toJSONOptions))\n    : subitem.toJSON(toJSONOptions)\n}\n\n// ---\n\nexport async function deleteById({\n  doc,\n  Model,\n  req,\n  subarray,\n  subId,\n}: Pick<IBaseOptions, 'doc' | 'Model' | 'req' | 'subarray' | 'subId'> & {\n  subarray: Types.DocumentArray<Types.Subdocument>\n}) {\n  const _prev = doc.toJSON(toJSONOptions)\n\n  const subitem = subarray.id(subId)\n\n  if (!subitem) throw httpErrors.notFound(SUBITEM_NOT_FOUND)\n\n  subitem.deleteOne()\n\n  await useSession(\n    Model,\n    req,\n    // @ts-ignore: custom arg req\n    (session?: ClientSession) => doc.save({ req, session, _prev })\n  )\n\n  return subarray.map((subitem) => subitem.toJSON(toJSONOptions))\n}\n", "export const leanOptions = {\n  virtuals: true,\n  versionKey: false,\n}\n\nexport const toJSONOptions = {\n  virtuals: true,\n  versionKey: false,\n}\n\nexport const memoOptions = {\n  maxAge: 24 * 24 * 60 * 60 * 1_000, // 24 days\n}\n\nexport const store = {\n  mongoDatabaseName: '',\n  mongoUser: '',\n  mongoPassword: '',\n  mongoBaseUrl: 'mongodb://localhost:27016',\n  mongoAdminSource: 'admin',\n  mongoMinPoolSize: 2,\n  mongoMaxPoolSize: 20,\n}\n", "import { ClientSession, Model } from 'mongoose'\nimport { FastifyRequest } from 'fastify'\nimport { httpErrors } from '@fastify/sensible'\nimport {\n  DOCUMENT_NOT_FOUND,\n  EMPTY_BODY,\n  INVALID_BODY,\n  SUBARRAY_NOT_FOUND,\n  SUBITEM_NOT_FOUND,\n} from '../mrq.errors'\nimport { model } from './db.utils'\nimport { leanOptions } from '../mrq.config'\nimport { MrqDocument } from '../mrq.interfaces'\nimport fp from 'lodash/fp'\n\ninterface IRunStaticMethods<T> {\n  Model: Model<T>\n  docs: any[]\n  query: { select: { [key: string]: number } }\n  req: FastifyRequest\n}\n\n// ---\n\nexport function runStaticMethods<T>({\n  Model,\n  docs,\n  query,\n  req,\n}: IRunStaticMethods<T>) {\n  for (const staticMethodName in Model.schema.statics) {\n    if (query.select[staticMethodName] !== 1) continue\n\n    for (const doc of docs)\n      doc[staticMethodName] = Model.schema.statics[staticMethodName].call(\n        Model,\n        doc,\n        { req, query }\n      )\n  }\n}\n\n// ---\n\nexport async function useSession(\n  Model: Model<any>,\n  req: FastifyRequest,\n  cb: (session?: ClientSession) => any\n) {\n  const query = req.query as { useSession: string }\n  const shouldUseSession = query.useSession === 'true'\n\n  if (!shouldUseSession) return cb()\n\n  const session = await Model.startSession()\n  const res = await cb(session)\n  session.endSession()\n\n  return res\n}\n\n// ---\n\nexport function getArrayFromBodyWithId(body: any[]) {\n  if (!Array.isArray(body))\n    throw httpErrors.unprocessableEntity(\n      `${INVALID_BODY}: body should be an array`\n    )\n\n  if (!body.length)\n    throw httpErrors.unprocessableEntity(\n      `${EMPTY_BODY}: body should contain at least one object`\n    )\n\n  body = body.filter((doc) => doc._id)\n\n  if (!body.length)\n    throw httpErrors.unprocessableEntity(\n      `${INVALID_BODY}: body should contain at least one object with _id`\n    )\n\n  return body\n}\n\n// ---\n\nexport async function getSubarray(\n  req: FastifyRequest,\n  modelName: string,\n  subPathName_: string,\n  useLean: boolean = false\n): Promise<{ Model: Model<any>; doc: MrqDocument; subarray: any }> {\n  const Model = model(req, modelName)\n\n  const { id } = req.params as { id: string }\n\n  const [subPathName] = subPathName_.split(':')\n\n  const p = Model.findById(id, {}, { req }).select(subPathName)\n\n  const doc: MrqDocument = await (useLean ? p.lean(leanOptions) : p)\n\n  if (!doc) throw httpErrors.notFound(DOCUMENT_NOT_FOUND)\n\n  if (!doc[subPathName]) throw httpErrors.notFound(SUBARRAY_NOT_FOUND)\n\n  return {\n    Model,\n    doc,\n    subarray: doc[subPathName],\n  }\n}\n\n// ---\n\nexport async function getChildarray(\n  req: FastifyRequest,\n  modelName: string,\n  fullPathName: string,\n  useLean: boolean = false\n) {\n  const Model = model(req, modelName)\n\n  const { id, subId } = req.params as { id: string; subId: string }\n\n  const [subPathName, childPathName] = fullPathName.split(':')\n\n  const p = Model.find(\n    {\n      _id: id,\n      [`${subPathName}._id`]: subId,\n    },\n    {},\n    { req }\n  ).select(`\n      ${subPathName}._id\n      ${subPathName}.${childPathName}\n    `)\n\n  const [doc]: any[] = (await (useLean ? p.lean(leanOptions) : p)) ?? []\n\n  if (!doc) throw httpErrors.notFound(DOCUMENT_NOT_FOUND)\n\n  const subitem = fp.find((subitem) => subitem._id.equals(subId), doc[subPathName])\n\n  if (!subitem) throw httpErrors.notFound(SUBITEM_NOT_FOUND)\n\n  return {\n    Model,\n    doc,\n    subitem,\n    subarray: subitem[childPathName],\n  }\n}\n", "export const SCHEMA_NOT_REGISTERED = 'SCHEMA_NOT_REGISTERED'\n\nexport const SESSION_NOT_FOUND = 'SESSION_NOT_FOUND'\n\nexport const IMPLICIT_SELECT_ALL_NOT_ALLOWED = 'IMPLICIT_SELECT_ALL_NOT_ALLOWED'\n\nexport const ROLE_DOES_NOT_HAVE_ACCESS_HOOK_LEVEL =\n  'ROLE_DOES_NOT_HAVE_ACCESS_HOOK_LEVEL'\n\nexport const ROLE_DOES_NOT_HAVE_ACCESS_HANDLER_LEVEL =\n  'ROLE_DOES_NOT_HAVE_ACCESS_HANDLER_LEVEL'\n\nexport const PATH_NOT_FOUND_IN_SCHEMA = 'PATH_NOT_FOUND_IN_SCHEMA'\n\nexport const IMPLICIT_DELETE_ALL_NOT_ALLOWED = 'IMPLICIT_DELETE_ALL_NOT_ALLOWED'\n\nexport const NO_DOCUMENT_FOUND = 'NO_DOCUMENT_FOUND'\n\nexport const INVALID_BODY = 'INVALID_BODY'\n\nexport const EMPTY_BODY = 'EMPTY_BODY'\n\nexport const DOCUMENT_NOT_FOUND = 'DOCUMENT_NOT_FOUND'\n\nexport const SUBARRAY_NOT_FOUND = 'SUBARRAY_NOT_FOUND'\n\nexport const NO_SUBITEM_FOUND = 'NO_SUBITEM_FOUND'\n\nexport const SUBITEM_NOT_FOUND = 'SUBITEM_NOT_FOUND'\n", "import { FastifyInstance, FastifyRequest } from 'fastify'\nimport { httpErrors } from '@fastify/sensible'\nimport { Connection, createConnection, IndexesDiff } from 'mongoose'\nimport fp from 'lodash/fp'\nimport promiseAll from 'promise-all'\nimport { IModelToSchemaMap } from '../mrq.interfaces'\nimport { SCHEMA_NOT_REGISTERED } from '../mrq.errors'\nimport { store } from '../mrq.config'\n\nlet connGlobal: Connection\n\nexport async function initConnection() {\n  const mongoUrl = `${store.mongoBaseUrl}/${store.mongoDatabaseName ?? ''}`\n\n  connGlobal = await createConnection(mongoUrl, {\n    autoIndex: false,\n    auth: {\n      username: store.mongoUser,\n      password: store.mongoPassword,\n    },\n    authSource: store.mongoAdminSource,\n    minPoolSize: store.mongoMinPoolSize,\n    maxPoolSize: store.mongoMaxPoolSize,\n  }).asPromise()\n}\n\nexport async function getDB(\n  app: FastifyInstance,\n  databaseName: string,\n  schemas: IModelToSchemaMap\n) {\n  let connDB: Connection\n\n  if (store.mongoDatabaseName) connDB = connGlobal\n  else\n    connDB = await connGlobal\n      .useDb(databaseName, { useCache: true })\n      .asPromise()\n\n  if (!connDB.get('hasMapModelsBeenCalled'))\n    await mapModels(app, connDB, schemas)\n\n  return connDB\n}\n\nasync function mapModels(\n  app: FastifyInstance,\n  connDB: Connection,\n  schemas: IModelToSchemaMap\n) {\n  connDB.set('hasMapModelsBeenCalled', true)\n\n  const p: { [modelName: string]: Promise<IndexesDiff> } = {}\n\n  connDB.securePathsPerModel = {}\n\n  for (const modelName in schemas) {\n    const schema = schemas[modelName]\n\n    if (modelName in connDB.models) continue\n\n    const Model = connDB.model(modelName, schema)\n\n    p[modelName] = Model.diffIndexes()\n\n    schema.eachPath((path, schemaType) => {\n      if (!connDB.securePathsPerModel[modelName])\n        connDB.securePathsPerModel[modelName] = {}\n\n      if (schemaType.options.secure)\n        connDB.securePathsPerModel[modelName][path] = true\n    })\n  }\n\n  const diffs = await promiseAll(p).then(\n    fp.pickBy<IndexesDiff>((v, k) => v.toDrop.length || v.toCreate.length)\n  )\n\n  const hasAnyDiff = Object.keys(diffs).length\n\n  if (hasAnyDiff)\n    app.log.info('Result of diffIndexes:', JSON.stringify(diffs, null, 2))\n}\n\nexport async function closeConnections() {\n  await connGlobal.close()\n}\n\nexport function model(req: FastifyRequest, modelName: string) {\n  const Model = req.mongooseConn.models[modelName]\n\n  if (!Model) throw httpErrors.badRequest(SCHEMA_NOT_REGISTERED)\n\n  return Model\n}\n"],
  "mappings": "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",
  "names": ["import_fp", "import_sensible", "import_fp", "import_sensible", "fp", "sift", "subitem"]
}
