{
  "version": 3,
  "sources": ["../../src/utils/mongoose.utils.ts", "../../src/mrq.errors.ts", "../../src/utils/db.utils.ts", "../../src/mrq.config.ts"],
  "sourcesContent": ["import { ClientSession, Model } from 'mongoose'\nimport { FastifyRequest } from 'fastify'\nimport { httpErrors } from '@fastify/sensible'\nimport {\n  DOCUMENT_NOT_FOUND,\n  EMPTY_BODY,\n  INVALID_BODY,\n  SUBARRAY_NOT_FOUND,\n  SUBITEM_NOT_FOUND,\n} from '../mrq.errors'\nimport { model } from './db.utils'\nimport { leanOptions } from '../mrq.config'\nimport { MrqDocument } from '../mrq.interfaces'\nimport fp from 'lodash/fp'\n\ninterface IRunStaticMethods<T> {\n  Model: Model<T>\n  docs: any[]\n  query: { select: { [key: string]: number } }\n  req: FastifyRequest\n}\n\n// ---\n\nexport function runStaticMethods<T>({\n  Model,\n  docs,\n  query,\n  req,\n}: IRunStaticMethods<T>) {\n  for (const staticMethodName in Model.schema.statics) {\n    if (query.select[staticMethodName] !== 1) continue\n\n    for (const doc of docs)\n      doc[staticMethodName] = Model.schema.statics[staticMethodName].call(\n        Model,\n        doc,\n        { req, query }\n      )\n  }\n}\n\n// ---\n\nexport async function useSession(\n  Model: Model<any>,\n  req: FastifyRequest,\n  cb: (session?: ClientSession) => any\n) {\n  const query = req.query as { useSession: string }\n  const shouldUseSession = query.useSession === 'true'\n\n  if (!shouldUseSession) return cb()\n\n  const session = await Model.startSession()\n  const res = await cb(session)\n  session.endSession()\n\n  return res\n}\n\n// ---\n\nexport function getArrayFromBodyWithId(body: any[]) {\n  if (!Array.isArray(body))\n    throw httpErrors.unprocessableEntity(\n      `${INVALID_BODY}: body should be an array`\n    )\n\n  if (!body.length)\n    throw httpErrors.unprocessableEntity(\n      `${EMPTY_BODY}: body should contain at least one object`\n    )\n\n  body = body.filter((doc) => doc._id)\n\n  if (!body.length)\n    throw httpErrors.unprocessableEntity(\n      `${INVALID_BODY}: body should contain at least one object with _id`\n    )\n\n  return body\n}\n\n// ---\n\nexport async function getSubarray(\n  req: FastifyRequest,\n  modelName: string,\n  subPathName_: string,\n  useLean: boolean = false\n): Promise<{ Model: Model<any>; doc: MrqDocument; subarray: any }> {\n  const Model = model(req, modelName)\n\n  const { id } = req.params as { id: string }\n\n  const [subPathName] = subPathName_.split(':')\n\n  const p = Model.findById(id, {}, { req }).select(subPathName)\n\n  const doc: MrqDocument = await (useLean ? p.lean(leanOptions) : p)\n\n  if (!doc) throw httpErrors.notFound(DOCUMENT_NOT_FOUND)\n\n  if (!doc[subPathName]) throw httpErrors.notFound(SUBARRAY_NOT_FOUND)\n\n  return {\n    Model,\n    doc,\n    subarray: doc[subPathName],\n  }\n}\n\n// ---\n\nexport async function getChildarray(\n  req: FastifyRequest,\n  modelName: string,\n  fullPathName: string,\n  useLean: boolean = false\n) {\n  const Model = model(req, modelName)\n\n  const { id, subId } = req.params as { id: string; subId: string }\n\n  const [subPathName, childPathName] = fullPathName.split(':')\n\n  const p = Model.find(\n    {\n      _id: id,\n      [`${subPathName}._id`]: subId,\n    },\n    {},\n    { req }\n  ).select(`\n      ${subPathName}._id\n      ${subPathName}.${childPathName}\n    `)\n\n  const [doc]: any[] = (await (useLean ? p.lean(leanOptions) : p)) ?? []\n\n  if (!doc) throw httpErrors.notFound(DOCUMENT_NOT_FOUND)\n\n  const subitem = fp.find((subitem) => subitem._id.equals(subId), doc[subPathName])\n\n  if (!subitem) throw httpErrors.notFound(SUBITEM_NOT_FOUND)\n\n  return {\n    Model,\n    doc,\n    subitem,\n    subarray: subitem[childPathName],\n  }\n}\n", "export const SCHEMA_NOT_REGISTERED = 'SCHEMA_NOT_REGISTERED'\n\nexport const SESSION_NOT_FOUND = 'SESSION_NOT_FOUND'\n\nexport const IMPLICIT_SELECT_ALL_NOT_ALLOWED = 'IMPLICIT_SELECT_ALL_NOT_ALLOWED'\n\nexport const ROLE_DOES_NOT_HAVE_ACCESS_HOOK_LEVEL =\n  'ROLE_DOES_NOT_HAVE_ACCESS_HOOK_LEVEL'\n\nexport const ROLE_DOES_NOT_HAVE_ACCESS_HANDLER_LEVEL =\n  'ROLE_DOES_NOT_HAVE_ACCESS_HANDLER_LEVEL'\n\nexport const PATH_NOT_FOUND_IN_SCHEMA = 'PATH_NOT_FOUND_IN_SCHEMA'\n\nexport const IMPLICIT_DELETE_ALL_NOT_ALLOWED = 'IMPLICIT_DELETE_ALL_NOT_ALLOWED'\n\nexport const NO_DOCUMENT_FOUND = 'NO_DOCUMENT_FOUND'\n\nexport const INVALID_BODY = 'INVALID_BODY'\n\nexport const EMPTY_BODY = 'EMPTY_BODY'\n\nexport const DOCUMENT_NOT_FOUND = 'DOCUMENT_NOT_FOUND'\n\nexport const SUBARRAY_NOT_FOUND = 'SUBARRAY_NOT_FOUND'\n\nexport const NO_SUBITEM_FOUND = 'NO_SUBITEM_FOUND'\n\nexport const SUBITEM_NOT_FOUND = 'SUBITEM_NOT_FOUND'\n", "import { FastifyInstance, FastifyRequest } from 'fastify'\nimport { httpErrors } from '@fastify/sensible'\nimport { Connection, createConnection, IndexesDiff } from 'mongoose'\nimport fp from 'lodash/fp'\nimport promiseAll from 'promise-all'\nimport { IRestOptions } from '../mrq.interfaces'\nimport { SCHEMA_NOT_REGISTERED } from '../mrq.errors'\nimport { store } from '../mrq.config'\n\nconst pool: { [key: string]: Connection } = {}\n\nlet singleConnection: Connection | null = null\n\nexport async function getSingleConnection(\n  app: FastifyInstance,\n  opts: IRestOptions\n) {\n  if (!store.mongoPath) return\n  singleConnection = await getDB(app, store.mongoPath, opts.schemas)\n}\n\nexport async function getDB(\n  app: FastifyInstance,\n  uri: string,\n  schemas: IRestOptions['schemas']\n) {\n  if (singleConnection) return singleConnection\n\n  let conn: Connection = pool[uri]\n\n  if (!conn) {\n    conn = createConnection(uri, {\n      autoIndex: false,\n      auth: {\n        username: store.mongoUser,\n        password: store.mongoPassword,\n      },\n      authSource: store.mongoAdminSource,\n    })\n\n    await conn.asPromise()\n\n    pool[uri] = conn\n\n    await mapModels(app, conn, schemas)\n  }\n\n  return conn\n}\n\nasync function mapModels(\n  app: FastifyInstance,\n  conn: Connection,\n  schemas: IRestOptions['schemas']\n) {\n  const p: { [modelName: string]: Promise<IndexesDiff> } = {}\n\n  conn.securePathsPerModel = {}\n\n  for (const modelName in schemas) {\n    const { schema } = schemas[modelName]\n\n    if (modelName in conn.models) continue\n\n    const Model = conn.model(modelName, schema)\n\n    p[modelName] = Model.diffIndexes()\n\n    schema.eachPath((path, schemaType) => {\n      if (!conn.securePathsPerModel[modelName])\n        conn.securePathsPerModel[modelName] = {}\n\n      if (schemaType.options.secure)\n        conn.securePathsPerModel[modelName][path] = true\n    })\n  }\n\n  const diffs = await promiseAll(p).then(\n    fp.pickBy<IndexesDiff>((v, k) => v.toDrop.length || v.toCreate.length)\n  )\n\n  const hasAnyDiff = Object.keys(diffs).length\n\n  if (hasAnyDiff)\n    app.log.info('Result of diffIndexes:', JSON.stringify(diffs, null, 2))\n}\n\nexport async function closeConnections() {\n  const p = []\n\n  for (const uri in pool) p.push(pool[uri].close())\n\n  await Promise.allSettled(p)\n}\n\nexport function model(req: FastifyRequest, modelName: string) {\n  const Model = req.mongooseConn.models[modelName]\n\n  if (!Model) throw httpErrors.badRequest(SCHEMA_NOT_REGISTERED)\n\n  return Model\n}\n", "export const leanOptions = {\n  virtuals: true,\n  versionKey: false,\n}\n\nexport const toJSONOptions = {\n  virtuals: true,\n  versionKey: false,\n}\n\nexport const memoOptions = {\n  maxAge: 30 * 24 * 60 * 60 * 1_000, // 1 month\n}\n\nexport const store = {\n  mongoPath: '',\n  mongoUser: '',\n  mongoPassword: '',\n  mongoAdminSource: 'admin',\n}\n"],
  "mappings": "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",
  "names": ["import_sensible", "import_fp", "fp", "subitem"]
}
