{
  "version": 3,
  "sources": ["../../src/utils/mongoose.utils.ts"],
  "sourcesContent": ["import { ClientSession, Model } from 'mongoose'\nimport { FastifyRequest } from 'fastify'\nimport { httpErrors } from '@fastify/sensible'\nimport {\n  DOCUMENT_NOT_FOUND,\n  EMPTY_BODY,\n  INVALID_BODY,\n  SUBARRAY_NOT_FOUND,\n  SUBITEM_NOT_FOUND,\n} from '../mrq.errors'\nimport { model } from './db.utils'\nimport { leanOptions } from '../mrq.config'\nimport { MrqDocument } from '../mrq.interfaces'\nimport { find } from 'lodash/fp'\n\ninterface IRunStaticMethods<T> {\n  Model: Model<T>\n  docs: any[]\n  query: { select: { [key: string]: number } }\n  req: FastifyRequest\n}\n\n// ---\n\nexport function runStaticMethods<T>({\n  Model,\n  docs,\n  query,\n  req,\n}: IRunStaticMethods<T>) {\n  for (const staticMethodName in Model.schema.statics) {\n    if (query.select[staticMethodName] !== 1) continue\n\n    for (const doc of docs)\n      doc[staticMethodName] = Model.schema.statics[staticMethodName].call(\n        Model,\n        doc,\n        { req, query }\n      )\n  }\n}\n\n// ---\n\nexport async function useSession(\n  Model: Model<any>,\n  req: FastifyRequest,\n  cb: (session?: ClientSession) => any\n) {\n  const query = req.query as { useSession: string }\n  const shouldUseSession = query.useSession === 'true'\n\n  if (!shouldUseSession) return cb()\n\n  const session = await Model.startSession()\n  const res = await cb(session)\n  session.endSession()\n\n  return res\n}\n\n// ---\n\nexport function getArrayFromBodyWithId(body: any[]) {\n  if (!Array.isArray(body))\n    throw httpErrors.unprocessableEntity(\n      `${INVALID_BODY}: body should be an array`\n    )\n\n  if (!body.length)\n    throw httpErrors.unprocessableEntity(\n      `${EMPTY_BODY}: body should contain at least one object`\n    )\n\n  body = body.filter((doc) => doc._id)\n\n  if (!body.length)\n    throw httpErrors.unprocessableEntity(\n      `${INVALID_BODY}: body should contain at least one object with _id`\n    )\n\n  return body\n}\n\n// ---\n\nexport async function getSubarray(\n  req: FastifyRequest,\n  modelName: string,\n  subPathName_: string,\n  useLean: boolean = false\n): Promise<{ Model: Model<any>; doc: MrqDocument; subarray: any }> {\n  const Model = model(req, modelName)\n\n  const { id } = req.params as { id: string }\n\n  const [subPathName] = subPathName_.split(':')\n\n  const p = Model.findById(id, {}, { req }).select(subPathName)\n\n  const doc: MrqDocument = await (useLean ? p.lean(leanOptions) : p)\n\n  if (!doc) throw httpErrors.notFound(DOCUMENT_NOT_FOUND)\n\n  if (!doc[subPathName]) throw httpErrors.notFound(SUBARRAY_NOT_FOUND)\n\n  return {\n    Model,\n    doc,\n    subarray: doc[subPathName],\n  }\n}\n\n// ---\n\nexport async function getChildarray(\n  req: FastifyRequest,\n  modelName: string,\n  fullPathName: string,\n  useLean: boolean = false\n) {\n  const Model = model(req, modelName)\n\n  const { id, subId } = req.params as { id: string; subId: string }\n\n  const [subPathName, childPathName] = fullPathName.split(':')\n\n  const p = Model.find(\n    {\n      _id: id,\n      [`${subPathName}._id`]: subId,\n    },\n    {},\n    { req }\n  ).select(`\n      ${subPathName}._id\n      ${subPathName}.${childPathName}\n    `)\n\n  const [doc]: any[] = (await (useLean ? p.lean(leanOptions) : p)) ?? []\n\n  if (!doc) throw httpErrors.notFound(DOCUMENT_NOT_FOUND)\n\n  const subitem = find((subitem) => subitem._id.equals(subId), doc[subPathName])\n\n  if (!subitem) throw httpErrors.notFound(SUBITEM_NOT_FOUND)\n\n  return {\n    Model,\n    doc,\n    subitem,\n    subarray: subitem[childPathName],\n  }\n}\n"],
  "mappings": ";AAEA,SAAS,kBAAkB;AAC3B;AAAA,EACE;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,OACK;AACP,SAAS,aAAa;AACtB,SAAS,mBAAmB;AAE5B,SAAS,YAAY;AAWd,SAAS,iBAAoB;AAAA,EAClC;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,GAAyB;AACvB,aAAW,oBAAoB,MAAM,OAAO,SAAS;AACnD,QAAI,MAAM,OAAO,gBAAgB,MAAM,EAAG;AAE1C,eAAW,OAAO;AAChB,UAAI,gBAAgB,IAAI,MAAM,OAAO,QAAQ,gBAAgB,EAAE;AAAA,QAC7D;AAAA,QACA;AAAA,QACA,EAAE,KAAK,MAAM;AAAA,MACf;AAAA,EACJ;AACF;AAIA,eAAsB,WACpB,OACA,KACA,IACA;AACA,QAAM,QAAQ,IAAI;AAClB,QAAM,mBAAmB,MAAM,eAAe;AAE9C,MAAI,CAAC,iBAAkB,QAAO,GAAG;AAEjC,QAAM,UAAU,MAAM,MAAM,aAAa;AACzC,QAAM,MAAM,MAAM,GAAG,OAAO;AAC5B,UAAQ,WAAW;AAEnB,SAAO;AACT;AAIO,SAAS,uBAAuB,MAAa;AAClD,MAAI,CAAC,MAAM,QAAQ,IAAI;AACrB,UAAM,WAAW;AAAA,MACf,GAAG,YAAY;AAAA,IACjB;AAEF,MAAI,CAAC,KAAK;AACR,UAAM,WAAW;AAAA,MACf,GAAG,UAAU;AAAA,IACf;AAEF,SAAO,KAAK,OAAO,CAAC,QAAQ,IAAI,GAAG;AAEnC,MAAI,CAAC,KAAK;AACR,UAAM,WAAW;AAAA,MACf,GAAG,YAAY;AAAA,IACjB;AAEF,SAAO;AACT;AAIA,eAAsB,YACpB,KACA,WACA,cACA,UAAmB,OAC8C;AACjE,QAAM,QAAQ,MAAM,KAAK,SAAS;AAElC,QAAM,EAAE,GAAG,IAAI,IAAI;AAEnB,QAAM,CAAC,WAAW,IAAI,aAAa,MAAM,GAAG;AAE5C,QAAM,IAAI,MAAM,SAAS,IAAI,CAAC,GAAG,EAAE,IAAI,CAAC,EAAE,OAAO,WAAW;AAE5D,QAAM,MAAmB,OAAO,UAAU,EAAE,KAAK,WAAW,IAAI;AAEhE,MAAI,CAAC,IAAK,OAAM,WAAW,SAAS,kBAAkB;AAEtD,MAAI,CAAC,IAAI,WAAW,EAAG,OAAM,WAAW,SAAS,kBAAkB;AAEnE,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA,UAAU,IAAI,WAAW;AAAA,EAC3B;AACF;AAIA,eAAsB,cACpB,KACA,WACA,cACA,UAAmB,OACnB;AACA,QAAM,QAAQ,MAAM,KAAK,SAAS;AAElC,QAAM,EAAE,IAAI,MAAM,IAAI,IAAI;AAE1B,QAAM,CAAC,aAAa,aAAa,IAAI,aAAa,MAAM,GAAG;AAE3D,QAAM,IAAI,MAAM;AAAA,IACd;AAAA,MACE,KAAK;AAAA,MACL,CAAC,GAAG,WAAW,MAAM,GAAG;AAAA,IAC1B;AAAA,IACA,CAAC;AAAA,IACD,EAAE,IAAI;AAAA,EACR,EAAE,OAAO;AAAA,QACH,WAAW;AAAA,QACX,WAAW,IAAI,aAAa;AAAA,KAC/B;AAEH,QAAM,CAAC,GAAG,IAAY,OAAO,UAAU,EAAE,KAAK,WAAW,IAAI,MAAO,CAAC;AAErE,MAAI,CAAC,IAAK,OAAM,WAAW,SAAS,kBAAkB;AAEtD,QAAM,UAAU,KAAK,CAACA,aAAYA,SAAQ,IAAI,OAAO,KAAK,GAAG,IAAI,WAAW,CAAC;AAE7E,MAAI,CAAC,QAAS,OAAM,WAAW,SAAS,iBAAiB;AAEzD,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA;AAAA,IACA,UAAU,QAAQ,aAAa;AAAA,EACjC;AACF;",
  "names": ["subitem"]
}
