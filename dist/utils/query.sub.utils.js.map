{
  "version": 3,
  "sources": ["../../src/utils/query.sub.utils.ts", "../../src/mrq.config.ts", "../../src/utils/query.utils.ts", "../../src/mrq.errors.ts"],
  "sourcesContent": ["import memoize from 'moize'\nimport { parseFilter } from 'mongodb-query-parser'\nimport { IGetQueryOptions } from '../mrq.interfaces'\nimport { memoOptions } from '../mrq.config'\nimport { getSelect, getSort } from './query.utils'\n\nconst sortMap = {\n  '1': 'asc',\n  '-1': 'desc',\n}\n\nexport const getQueryForSubarray = memoize(getQueryForSubarray_, memoOptions)\n\nfunction getQueryForSubarray_(query: any, options: IGetQueryOptions = {}) {\n  const filterStr =\n    typeof query.filter !== 'string'\n      ? JSON.stringify(query.filter)\n      : query.filter\n\n  const filter = parseFilter(filterStr) ?? {}\n\n  const sort = getSortForSubArray(query.sort)\n\n  const select = getSelectForSubArray(query.select, options)\n\n  const skip = query.skip ? parseInt(query.skip) : 0\n\n  const limit = query.limit ? parseInt(query.limit) : Infinity\n\n  return {\n    filter,\n    sort,\n    select,\n    skip,\n    limit,\n  }\n}\n\nfunction getSelectForSubArray(select: string, options: IGetQueryOptions = {}) {\n  if (options.ignoreSelect) return null\n\n  const selectObject = getSelect(select)\n\n  const selectArr = []\n\n  for (const path in selectObject)\n    if (selectObject[path] === 1) selectArr.push(path)\n\n  if (!selectArr.includes('_id')) selectArr.push('_id')\n\n  return selectArr\n}\n\nfunction getSortForSubArray(sort: string) {\n  const sortObject: { [key: string]: '1' | '-1' } = getSort(sort)\n\n  const sortFieldsArr = []\n  const sortOrderArr = []\n\n  for (const sortField in sortObject) {\n    sortFieldsArr.push(sortField)\n    sortOrderArr.push(sortMap[sortObject[sortField] as keyof typeof sortMap])\n  }\n\n  return {\n    sortFieldsArr,\n    sortOrderArr,\n  }\n}\n", "export const leanOptions = {\n  virtuals: true,\n  versionKey: false,\n}\n\nexport const toJSONOptions = {\n  virtuals: true,\n  versionKey: false,\n}\n\nexport const memoOptions = {\n  maxAge: 30 * 24 * 60 * 60 * 1_000, // 1 month\n}\n\nexport const store = {\n  mongoPath: '',\n  mongoUser: '',\n  mongoPassword: '',\n  mongoAdminSource: 'admin',\n}\n", "import memoize from 'moize'\nimport { FastifyRequest } from 'fastify'\nimport { httpErrors } from '@fastify/sensible'\nimport { parseFilter, parseSort, parseProject } from 'mongodb-query-parser'\nimport { IMPLICIT_SELECT_ALL_NOT_ALLOWED } from '../mrq.errors'\nimport { IGetQueryOptions, MrqQuery } from '../mrq.interfaces'\nimport { memoOptions } from '../mrq.config'\n\ntype TypeSecurePaths = { [path: string]: boolean }\n\nexport function getQuery(\n  req: FastifyRequest,\n  modelName: string,\n  options: IGetQueryOptions = {}\n) {\n  const securePaths = req.mongooseConn.securePathsPerModel[modelName]\n\n  return getQueryInternal(req.query, securePaths, options)\n}\n\nconst getQueryInternal = memoize(getQueryInternal_, memoOptions)\n\nfunction getQueryInternal_(\n  query: any,\n  securePaths: TypeSecurePaths,\n  options: IGetQueryOptions = {}\n): MrqQuery {\n  const filter = getFilter(query.filter)\n\n  const sort = getSort(query.sort)\n\n  const select = getSelect(query.select, securePaths, options)\n\n  const populate = getPopulate(query.populate)\n\n  const skip = query.skip ? parseInt(query.skip) : 0\n\n  const limit = query.limit ? parseInt(query.limit) : 0\n\n  return {\n    filter,\n    sort,\n    select,\n    populate,\n    skip,\n    limit,\n  }\n}\n\nfunction getFilter(filter: string) {\n  const filterStr = typeof filter !== 'string' ? JSON.stringify(filter) : filter\n\n  return parseFilter(filterStr) ?? {}\n}\n\nexport function getSort(fields: string) {\n  if (!fields) return {}\n\n  const sort: Record<string, 1 | -1> = {}\n\n  const fieldList = fields.split(',').map((str) => str.trim())\n\n  for (const field of fieldList) {\n    if (field.startsWith('-')) sort[field.slice(1)] = -1\n    else sort[field] = 1\n  }\n\n  return parseSort(JSON.stringify(sort))\n}\n\nexport function getSelect(\n  fields: string = '',\n  securePaths: TypeSecurePaths = {},\n  options: IGetQueryOptions = {}\n) {\n  if (options.ignoreSelect) return {}\n\n  const select: Record<string, 1 | 0> = {}\n\n  const fieldList = fields\n    .split(',')\n    .map((str) => str.trim())\n    .filter(Boolean)\n\n  if (!fieldList.length)\n    throw httpErrors.methodNotAllowed(\n      `${IMPLICIT_SELECT_ALL_NOT_ALLOWED}: use select=all query param`\n    )\n\n  if (fieldList.includes('all'))\n    return transformSecurePathsToSelect(securePaths)\n\n  for (const field of fieldList) {\n    if (securePaths[field]) continue\n\n    if (field.startsWith('-')) select[field.slice(1)] = 0\n    else select[field] = 1\n  }\n\n  return parseProject(JSON.stringify(select))\n}\n\nfunction transformSecurePathsToSelect(securePaths: TypeSecurePaths) {\n  const select: Record<string, 1 | 0> = {}\n\n  for (const [path, value] of Object.entries(securePaths)) {\n    if (value) select[path] = 0\n  }\n\n  return select\n}\n\nfunction getPopulate(populate: string): any {\n  return parsePopulate(populate)\n}\n\nfunction parsePopulate(populate: string) {\n  try {\n    const parsed = JSON.parse(populate)\n\n    if (typeof parsed !== 'object') throw 1\n\n    // Sanitize normally is being done in parseFilter\n    return parseFilter(JSON.stringify(parsed))\n  } catch (e) {\n    return populate\n  }\n}\n", "export const SCHEMA_NOT_REGISTERED = 'SCHEMA_NOT_REGISTERED'\n\nexport const SESSION_NOT_FOUND = 'SESSION_NOT_FOUND'\n\nexport const IMPLICIT_SELECT_ALL_NOT_ALLOWED = 'IMPLICIT_SELECT_ALL_NOT_ALLOWED'\n\nexport const ROLE_DOES_NOT_HAVE_ACCESS_HOOK_LEVEL =\n  'ROLE_DOES_NOT_HAVE_ACCESS_HOOK_LEVEL'\n\nexport const ROLE_DOES_NOT_HAVE_ACCESS_HANDLER_LEVEL =\n  'ROLE_DOES_NOT_HAVE_ACCESS_HANDLER_LEVEL'\n\nexport const PATH_NOT_FOUND_IN_SCHEMA = 'PATH_NOT_FOUND_IN_SCHEMA'\n\nexport const IMPLICIT_DELETE_ALL_NOT_ALLOWED = 'IMPLICIT_DELETE_ALL_NOT_ALLOWED'\n\nexport const NO_DOCUMENT_FOUND = 'NO_DOCUMENT_FOUND'\n\nexport const INVALID_BODY = 'INVALID_BODY'\n\nexport const EMPTY_BODY = 'EMPTY_BODY'\n\nexport const DOCUMENT_NOT_FOUND = 'DOCUMENT_NOT_FOUND'\n\nexport const SUBARRAY_NOT_FOUND = 'SUBARRAY_NOT_FOUND'\n\nexport const NO_SUBITEM_FOUND = 'NO_SUBITEM_FOUND'\n\nexport const SUBITEM_NOT_FOUND = 'SUBITEM_NOT_FOUND'\n"],
  "mappings": "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",
  "names": ["import_moize", "import_mongodb_query_parser", "memoize", "memoize"]
}
